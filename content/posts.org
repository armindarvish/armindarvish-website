#+OPTIONS: author: nil
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_lastMod: t
#+hugo_front_matter_format: yaml

* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH Humble Beginnings                  :@software:@webdesign:@about:
CLOSED: [2023-02-09 Thu 11:49]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: Humble Beginnings
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle About this Website and Blog
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary The totally necessary "about this blog..." post to introduce this website and blog
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption: 'This art was generated by AI and /\\r|\\\\/|i|\\\\|'
  focal_point: 'center'
#+end_src
**** *TLDR*
I recently decided to redesign and revive my old website and in the process, I decided that I would like to make a habit of writing blog posts here on my own websites. I'll likely be covering a range of topics mostly around research especially in healthcare technology. I'll also share my experience with software tools and workflows for example "How I am using emacs and ox-hugo to write this post" or "using NLP and python to extract interesting information from patents" and ...

**** *How it all started*
I first started working on this website back in 2013. At the time, I was a PhD student at Drexel University working on solid-state nanopores biosensors. I wanted to make a website to showcase my research portfolio and interests and in the process learn more about web design, HTML and CSS as well. I figured I could host it on Drexel's personal web pages and that's how this project simply started. After some initial research, I thought it would be nice to make the website script-free (only HTML and CSS) and only use my own work meaning that everything from design elements (logos, buttons, etc.) to HTML blocks had to be my own creation and not someone else's work[fn:mywork]! The first draft of the design was ready in a few days, but design and coding took some time especially because I had to learn CSS from scratch and my design was tricky to implement because I had hexagons and diagonal borders (see this [[https://archive.armindarvish.com/research.html][link]] for example) which was not straightforward, especially with HTML and CSS only. The first version was published later in 2014 and soon after I added a skeleton for my native-speaking language, Farsi. However, in the meanwhile I got very busy with my PhD research and keeping everything up to date with two languages was simply more work than I anticipated, so the progress slowed down. I then graduated in the middle of 2016 and moved to Northern California to work for a small start-up, where I found myself spending an average of 12–14 hours a day at work[fn:longwork]. That left me with no time to work on any personal projects including this website. You can see the old design in [[https://archive.armindarvish.com/][archive]].

**** *A New Beginning*
The project was abandoned for years with no updates while I was working for start-up companies in Silicon Valley. Then in 2019, I decided to leave the start-up scene and its ridiculously long working hours for greener pastures in a bigger, more stable company with more humane hours, and once again I found some time to consider personal projects and decided to bring this website back alive. The idea was further reinforced by the fact that the hosting server I was using was shut down by Drexel University. I decided it would be better to use a whole new set of tool chain, since the old website with HTML and CSS was not easy to maintain, plus the fact that this was again a good opportunity to learn new tools and skills. After some brief research I decided that I want to use [[https://gohugo.io/][Hugo]] combined with [[https://www.github.com/][GitHub]] and [[https://www.netlify.com/][Netlify]][fn:Netlify], and after some more browsing, looking at other people's examples (e.g. [[https://www.aidanscannell.com/][Aidan Scannell's Page]]), and reading online instructions (like [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][this one]]), I decided to give [[https://academic-demo.netlify.app/]["Academic Theme"]] from [[https://wowchemy.com/][wowchemy]] a try and the result is what you are looking at.

**** *Going Forward*
CLOSED: [2023-02-09 Thu 11:47]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:END:
Using Hugo and Netlify, made it really easy to update my website in more than one language as well. In fact it is easy enough to update that I have decided I can keep a blog here. In the past I have written scattered notes here and there on different social media platforms but going forward I'd like to keep everything here on my own website. My new goal in this project is to make a habit of writing short posts on interesting topics and build a collection of thought, ideas, tutorials over time. I will likely write about various topics I am interested in like biotech, nanosensors, and healthcare technology.  In addition, I will be writing posts on some software tools like interesting work flows in emacs including the one I am using to make this very post right now or how to use midjourney to make interesting backgrounds for your website, or using python and NLP to extract detailed technical information from Google Patents, and ...

While this is going to be a multilinqual blog, not all posts will be available in all languages.  My thoughts, experiences and perhaps even my personality is not always identical in environments with different languages, and therefore, the contents of my posts will reflect that reality. 


*** PUBLISH Emacs Workflow: Dynamically Adding Files to Org Agenda :@software:@emacs:@orgmode:
CLOSED: [2023-05-22 Mon 10:32]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files
:EXPORT_FILE_NAME: index
:TITLE: dynamically adding files to org-agenda-files in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to automatically and dynamically build org-agenda-files to include any files with TODO items.
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I'll show you my workflow for automatically adding files with TODO items to org-agenda-files as soon as we open or save the file.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src


**** Intro

If you use Emacs org-mode for task management, you have probably wondered if there is a way to dynamically add files with TODO items to org-agenda-files. A Google search will likely get you some initial ideas on how to do it. For example this post: [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][Boris Buliga - Task management with org-roam Vol. 5: Dynamic and fast agenda]] covers how to this. But since Boris's post focuses on using org-roam, it may not be the right solution when you use org-roam. So I had to hack my own solution and in this point I'm going to share that with you in case anyone is interested. You can see a [[file:en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamic_org_agenda.gif][screenshot]] below.


**** How does it work

For the main functionalities, I am using [[https://orgmode.org/worg/dev/org-element-api.html][Org Element API]] to parse org-mode buffers and find org TODO items. If there is a =TODO= item in the buffer, and it is visiting a file, I add the file to =org-agenda-files=. Additionally, I make sure that =org-agenda-files= is remembered between different Emacs sessions, I add =org-agenda-files= to =savehist-additional-variables=.

Then I define custom functions for and add them as hooks to org-mode to update =org-agenda-files= when an org-mode file is opened as well as when an org-mode file is saved. The redundancy helps make sure that nothing is lost if there is a crash.


**** The code

- Check if the file contains a =TODO= item:

 Use =org-element-map= and =org-element-parse-buffer= to walk the buffer, find all headlines and return true if there is any headline that is a =TODO= item. Note that I am looking for any heading that is a =TODO= item. Alternatively you can check for specific =TODO= types by looking at =:todo-keyword= instead of =:todo-type= e.g. =(org-element-property :todo-keyword h)...=

#+begin_src emacs-lisp
(defun ad/agenda-file-p ()
    (org-element-map
       (org-element-parse-buffer 'headline)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match))
#+end_src

- make a custom function to update =org-agenda-files= if the current org-mode file contains a =TODO= item:

If the current buffer contains a =TODO= item, I use seq-difference to find out if the files are already in org-agenda-files. If it does not contain =TODO= item, I make sure to remove it from =org-agenda-files=. This is important because when I'm done with a =TODO= item and remove it from the file, I would want the file to be removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-update-files (&rest ARG)
  ;; check if this is an org file buffer
  (interactive)
    (when (and (derived-mode-p 'org-mode) (buffer-file-name))
      (message "updating org-agenda-files...")
      ;; if there is an active TODO task, add this file to agenda files
      (if (ad/agenda-file-p)
      (add-to-list 'org-agenda-files (file-truename (buffer-file-name)))
      ;; if there is no active TODO task, remove the file from agenda files if needed
      (setq org-agenda-files (seq-difference org-agenda-files (list (buffer-file-name))))
      (customize-save-variable 'org-agenda-files org-agenda-files)
      ))
      )

#+end_src

- cleaning up =org-agenda-files= and remove files that don't exist anymore.

When I delete some files, I want to make sure it gets removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-cleanup-files (&rest ARG)
  (interactive)
  (let ((temp/org-agenda-files org-agenda-files))
  (dolist (file org-agenda-files)
  (if (not (file-exists-p file))
      (setq temp/org-agenda-files (seq-difference temp/org-agenda-files (list file))))
    ())
  (setq org-agenda-files temp/org-agenda-files))
  )
#+end_src

- Adding hooks

To get my functions to run automatically, I add =hooks= to =org-mode=. I make =lambda= functions that are added as hooks to =find-file-hook= and =before-save-hook= to make sure that =org-agenda-files= gets updated whenever I open an org-mode file and then again when I save the file.

#+begin_src emacs-lisp
;; Add or remove individual file
(add-hook 'org-mode-hook (lambda () (add-hook 'find-file-hook #'ad/org-agenda-update-files)))
(add-hook 'org-mode-hook (lambda () (add-hook 'before-save-hook #'ad/org-agenda-update-files)))
#+end_src

- Adding advice to functions that use =org-agenda-files= to show =TODO= items.

Before I run =org-agenda= or =dashboard-get-agenda=, or any other function that reads =org-agenda-files= to show my =TODO= items, I need to make sure to remove non-existing files from =org-agenda-files=.

#+begin_src emacs-lisp
;; remove non-existing files before building agenda
(advice-add 'org-agenda :before #'ad/org-agenda-cleanup-files)
(advice-add 'org-todo-list :before #'ad/org-agenda-cleanup-files)
(advice-add 'dashboard-get-agenda :before #'ad/org-agenda-cleanup-files)
#+end_src

- Make sure =org-agenda-files= is remembered between Emacs sessions.

I add =org-agenda-files= to =savehis-additional-variables= and make sure that =savehist-mode= is enabled.

#+begin_src emacs-lisp
(add-to-list 'savehist-additional-variables 'org-agenda-files)
#+end_src

**** Performance
Of course adding files dynamically to the =org-agenda-files= comes with a cost. Make too many files with org-agenda items and it will be very slow. Personally I keep most of my general =TODO= items in one file under my main org directory and only put =TODO= items in other files when having it in the context of the specific project is useful.

**** Screenshot

Here is a screenshot showing it in action. I open an org file and a =TODO= item in it and save it and as you can see once I refresh the buffer describing =org-agenda-files= variable, the new file is added to the list. I also show that once I remove the =TODO= item or mark it as DONE, it is automatically removed from the list. Also, you can see that once I have the new file in the org-agenda list, it automatically shows up on my dashboard.

#+ATTR_ORG: :width 800px :height nil px
#+ATTR_LATEX: :width 800px :height nil px
#+ATTR_HTML: :width 800px :height nil px
[[file:~/projects/armindarvish-website/content/en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamics_org_agenda.gif]]

*** PUBLISH Building the Best Blog Editor with Emacs Org-Mode in 2023?
CLOSED: [2023-06-20 Tue 01:23]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Building_An_Efficient_Blogging_Workflow_in_Emacs
:EXPORT_FILE_NAME: index
:TITLE: Building An Efficient Blogging Workflow in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to use org-mode and ox-hugo along with org-todo items and org-agenda to manage your blog posts
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I will show you my custom workflow in Emacs for writing blog posts. I use org-mode for writing the text and ox-hugo for exporting to markdown files. The post focuses on how to create a custom workflow starting with capturing the initial idea with org-capture, then using org-todo and org-agenda to track the post as you take it from idea to an initial draft through different stages of editing to finally publishing it on your website.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
categories: ["software", "emacs", "org mode", "blogging"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
#+end_src

In the previous post, I showed you how to automatically add files to your org-agenda. In this post I am going to expand on that and show you how to use =org-todo= items beyond tasks and todo lists and build custom workflows. As an example, I am going to show you my blogging workflow. This is what I am using right now to write this post, and in my opinion, it showcases the true power of Emacs and org-mode. If you want to know why Emacs is the one of the best tools for writing blogs in 2023, read on.

But before we get down to the point, let me make one thing clear: This is not a post about the basics of Emacs or org-mode and won't be giving you any configurations for writing text in Emacs either (although I will share some tips and tools as needed), instead it focuses on creating efficient workflows with automation using org-mode features that make Emacs superior to other available tools. Specifically I will show you:
1. Dynamic org-capture templates using Yasnippet snippets
2. Defining functions that are auto-triggered when an org-todo keyword is changed.
3. Some tips on custom org-agenda views to only look at items in a specific workflow
4. Extra tips for improving the look and feel and creating an intuitive user-friendly experience in org-mode
If you don't know much about Emacs or org-mode, or all you are looking for is a list of packages and settings that are useful for wiring non-programming text in Emacs, then I suggest to start elsewhere (You can find lots of good resources here:  [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]]) and come back to this post later, when you feel the need to take your workflow to the next level.

Also, note that while I am using a blog post as an example here, this general approach can be applied to many other scenarios, for example a bunch of flash cards you want to memorize; a selection of books you want to read, digest or summarize; a list of companies you want to apply for a job at; a bunch of projects you want to work on; and so on.

**** Using =org-todo= keywords
By default [[https://orgmode.org/][Emacs Org mode]] comes with two =org-todo= keywords ="TODO"= and ="DONE"= but you can add any custom keyword and use them to track different objects and category of items such as notes, flashcards, ideas, drafts, etc. You can do this by adding the labels to =org-todo-keywords= in a sequence following [[https://orgmode.org/manual/Workflow-states.html][Workflow states (The Org Manual)]]. For example for a blogging workflow I use =(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)")= as shown below. Note that by putting *PUBLISH* after "|", we are setting *PUBLISH* as the done label for this workflow, which can be used for other useful functions such as logging time, etc. (see the section on automating workflow [[Automating the Workflow][below]] for how I use it to automate logging times).

#+begin_src emacs-lisp
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))
#+end_src

Now, we can label org headings as a blog post by adding *DRAFT* todo keyword. This will serve as an entry point to capture ideas for a blog and add it to my agenda to edit later. As I edit the post and decide to publish it on my website, I'll change the label to *POST* or *PUBLISH*. I am going to show you how to use this to create some automated workflow but before that I am going to introduce another tool, Ox-Hugo, that makes it easy to write blog posts in org-mode if you use the static site generator, [[https://gohugo.io/][Hugo]].

**** Ox-Hugo
Next, we look at [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] that allows you to export texts written in org-mode to markdown files that are used by the [[https://gohugo.io/][Hugo]] static generator. If you use Hugo to build your blog, and want to write your posts in org-mode (which you should!), then [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] is a natural choice. There are other options such as =org-publish= as well, but I think Ox-Hugo is a better approach.

I recommend you go through Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]] for setting it up and find the specific settings that fit your need. But here are some ideas and tips to consider:

You can organize your blog posts either in separate files (one post per file) or all in one file under different org headings (one post per heading). Personally I am using one post per heading right now because I like to see all my posts in the same file next to each other. But if you prefer having the blog posts in different files, then you may want to consider my previous post [[https://www.armindarvish.com/en/post/emacs_workflow_dynamically_adding_files_to_org-agenda-files/][to dynamically add files to org-agendas]] so that every file gets added to your =org-agenda-files= automatically. Then you can use org-agenda views to browse through all your posts (see [[Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda][below]] for more on that).

Currently, I am using [[https://wowchemy.com/templates/][Wowchemy]]'s [[https://academic-demo.netlify.app/][Academic]] template for my website, so in my ox-hugo configuration, I set everything up according to the structure defined by that template. I use one org file for all my blog posts, and since I have a multilingual site, I put this file in my hugo website's folders under content alongside separate folders for each language. I then set up my ox-hugo to save each post in the appropriate folder by setting =:EXPORT_HUGO_SECTION_FRAG:= property. Because the properties are inherited, I can then use the same property in the subheadings of each post to point ox-hugo to save the post in the appropriate folder. For example for English posts I have something like the following in my file. As you can see I also add =YAML= source blocks for Wowchemy's settings following the documentation here: [[https://wowchemy.com/docs/][Hugo Documentation for Wowchemy]].

#+begin_src org
,* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
,** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

## Here I enter new posts##

,* DRAFT Title of the post

:PROPERTIES:
:EXPORT_HUGO_DRAFT: true
:EXPORT_HUGO_SECTION_FRAG: Title_of_the_post
:EXPORT_FILE_NAME: index
:TITLE: Title of the post
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle subtitle goes here
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary summary goes here
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [project]
categories: [tags]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
,#+end_src

#+end_src

I have a separate similar heading tree for other languages. With this setup I can use org-export with ox-hugo to automatically make the markdown files for each post.
Also, since my website is in a git repository, I keep a symlink copy of that file somewhere more convenient in my home folder such as ="~/blog/"= so I can quickly find my posts without navigating through the folder structure of my website.

Other than that there are some site-specific settings that I define in =:PROPERTIES:= drawers following Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]]. I also set up [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][auto export on saving.]]


**** Automating the Workflow
While the setup above is already great for writing posts in org-mode and quickly exporting them to markdown, we can do much more with org-mode =TODO= items. For example, we can create some automation flow by hooking functions to =org-after-todo-state-change-hook=, so your draft turns into a post on your hugo website automatically when you change the keyword. As a result, you can just focus on writing the contents rather than maintaining the blog files. This is what makes this workflow superior to a lot of other tools, because it brings the automation (that tools like WordPress offer) to a great text-editing environment like org-mode all within Emacs where I personally do a lot of other things (like coding, reading feeds, keeping notes, managing projects and ideas, ...).

*Here is my automated workflow (You can see a screenshot at the end of this post):*

I capture new ideas with org-capture (The next section, [[Using Org-Capture For Blog Ideas][Using Org Capture For Blog Ideas]], will cover how to set this up) under the *DRAFT* keyword and quickly add some rough ideas of what I want to add later. At this point, I rather not have it converted to markdown yet because maybe I end up deciding the topic is not right, and I don't even want to work on it until some other time. Later, when I find time to actually sit down and write up something, I go to my org-agenda list and find the blog post I want to work on and add some more contents and ideas and organize the post. I keep doing this over the next few days or weeks depending on availability until I get to a point when I feel that the content is indeed suitable for a blog post. At this point, I bump the heading to *POST* keyword, which automatically creates the markdown files. I am still not ready to publish this post because I probably don't have figures, and there are still minor details that need fixing. Therefore, in the markdown file, this is still marked as draft (determined by =:EXPORT_HUGO_DRAFT: true= in the properties' drawer), which allows me to see the post on my local web server (e.g. by running =hugo server -D= in the terminal) and decide how to polish and finalize it. Finally, when I'm done with editing the post and want to publish it on my website, I bump the heading up to *PUBLISH* and it automatically flags the post for publishing.

*Here is the code that enables the workflow:*

I have defined a function that changes =:EXPORT_HUGO_DRAFT:= property and also runs =(org-hugo-export-wim-to-md)= for me when I change the keyword.

#+begin_src emacs-lisp
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)
#+end_src

In the code above I am adding a function, =ad/org-change-draft-when-state-changes-to-publis= as a hook to run whenever a =TODO= keyword changes. This function runs =(org-hugo-export-wim-to-md)= to create the markdown files and also sets the =:EXPORT_HUGO_DRAFT:= to =true= or =false= depending on the status. Note that I have hooked the custom function to ='org-after-todo-state-change-hook= which runs on any =TODO= changes but since I am checking the todo state by =(org-get-todo-state)= this hook will only do something when the heading is one of *DRAFT*, *POST* or *PUBLISH*.

There are two more settings for my ideal setup to work as intended:
#+begin_src emacs-lisp
(setq org-log-done 'time
      org-log-into-drawer t)

(setq-default org-export-with-todo-keywords nil)
#+end_src

The code above makes sure that whenever a todo item is set as done (defined by putting the specific =TODO= keyword after ="|"= in the ='org-todo-keywords= list as mentioned [[*Using =org-todo= keywords][above]]). This is useful because ox-hugo uses this log time drawer to add the /"last updated timestamp"/ to markdown files.
Also, I make sure that =org-export-with-todo-keywords= is set to =nil=.

With this setup, I don't need to worry about anything but writing the content. As I change the =TODO= keyword, everything happens automatically in the background. In addition, I have everything set up with [[https://www.netlify.com/?utm_medium=paid_search&utm_source=google&utm_campaign=12755510784&utm_term=netlify][Netlify]] and [[https://github.com/][GitHub]], to automatically update my website when I push new changes to my git repository. As a result, the blogging workflow is as simple as capturing an idea and editing it in org-mode whenever I have time. Everything else happens magically in the background without me having to think or worry about it. Here is a screenshot showing how the new post gets added to the website when I change the keyword from *DRAFT* to *POST*.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/automatic_posting.gif]]

**** Using Org-Capture For Blog Ideas

The next useful step to take is to set up org-capture to quickly save new ideas. Often times blog ideas come to you randomly in the middle of something else, and you don't want to lose them. The org-mode ability to quickly fire up org-capture and write the idea down is therefore a crucial functionality that makes this workflow superior to a lot of other editors. To do this, I use the org-capture with a custom template. You can do this in different ways from minimal setup to more advanced ones, depending on your needs, as I show below.

***** Minimal Setup
You can add a simple template to your org-capture templates following the official instructions: [[https://orgmode.org/manual/Capture-templates.html][Capture templates (The Org Manual)]]. For example, the code below creates a new heading in the ="Blog.org"= file in default org directory under the Heading ="* Posts"=.

#+begin_src emacs-lisp
(add-to-list 'org-capture-templates
      `("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n"))
#+end_src

***** Better Set Up that Adds Ox-Hugo
The simple template above is sufficient for most basic workflows, but I personally like to use something a bit more advanced with automation and add capabilities for ox-hugo. Here is a better template which adds ox-hugo settings:

#+begin_src emacs-lisp
 (add-to-list 'org-capture-templates
      `(("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n:PROPERTIES:\n :EXPORT_HUGO_DRAFT: true\n :EXPORT_HUGO_SECTION_FRAG: \n :EXPORT_FILE_NAME: index\n :TITLE: \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary \n:END:\n\n#+begin_src yaml :front_matter_extra t\nauthors:\n  - admin\nprojects: []\nfeatured: false\ncommentable: true\nimage:\n  caption: 'caption'\n  focal_point: 'center'\n#+end_src\n"
         :empty-lines 1
         :prepend t
         :jump-to-captured t)
#+end_src

The code above adds the ox-hugo settings as =:PROPERTIES:= drawer to your entry and also adds some settings for convenience by =:prepend t= and =:jump-to-captured t=. It jumps to the file narrowed to the heading you just created in case you want to add some more text before finishing the capture process.

***** Advanced Setup with Ox-Hugo + Yasnippet
The template above covers provides all the essentials for an automated workflow, but it is still not the ideal version because but it is not dynamic enough, and some manual editing is still required. For example, I do not want to manually enter the file path for the markdown files. Therefore, in my own setup I take a different approach by using [[https://github.com/joaotavora/yasnippet][Yasnippet]] to do some auto-completion for me. Of course, this means that you need to install Yasnippet and set it up, which may not be what you want and hence the settings above, but in my case I am using Yasnippet for other things anyway, so I might as well use it here.

I define a capture function that calls org-capture but also enables yasnippet and inserts my snippet as a template. This is essentially a from with metadata fields that I can quickly jump to and fill by using the tab button.

#+begin_src emacs-lisp
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))
#+end_src
In the code above I use let-bindings to temporarily define a rather simple =org-capture-template= and call =(org-capture nil "d")= to get the org-capture buffer. Then I achieve the rest of what I need by loading and expanding a yasnippet snippet that contains the following:

#+begin_src emacs-lisp
# -*- mode: snippet -*-
# name: blog post template
# key:
# --
${1:title}
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: ${1:$(string-replace "\s" "_" yas-text)}
 :EXPORT_FILE_NAME: index
 :TITLE: $1
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle $2
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary $3
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [$4]
categories: [$5]
featured: false
commentable: true
image:
  caption: $6
  focal_point: 'center'
,#+end_src
$0
#+end_src

Note how the snippet takes the title and automatically generates the path for the markdown files using =:EXPORT_HUGO_SECTION_FRAG:=. In the screenshot below, you can see my capture process:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/org-capture.gif]]


**** Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda
An advantage of using org-todo keywords for items such as blog posts is that you can then quickly find all your items using [[https://orgmode.org/manual/Agenda-Views.html][Agenda Views]].

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))
#+end_src


Alternatively, you can use the awesome [[https://github.com/minad/consult][Consult Package]] by Alexander Miller and use =consult-org-agenda= to quickly search through your blog posts in the minibuffer. Here is some example code you can use after you install consult:

#+begin_src emacs-lisp
(consult-org-agenda "TODO={DRAFT\\|POST\\|PUBLISH}")
#+end_src

Personally, I have built some custom functions based on consult-agenda just for my blog posts that lists all my old posts with status and date, etc. and allows me to add new posts by entering a new title as well. I don't get into all that extra stuff in this post, but it is simply a custom setup for completing-read based on [[https://github.com/minad/consult][Consult]]. It allows me to see my previous posts or start new ones by entering a new title. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/consult-blog.gif]]

**** Bonus 2: Better looks for org-todo keywords
If you want to have some better looks for your org todo keywords, you can check the [[https://github.com/minad/org-modern][Org-Modern]] by Alexander Miller. If you want to have different faces or colors for different labels, you can set =org-todo-keyword-faces= per official instruction: [[https://orgmode.org/manual/Faces-for-TODO-keywords.html][Faces for TODO keywords (The Org Manual)]]. Here is an example:

#+begin_src emacs-lisp
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))
#+end_src


**** Bonus 3: Better Writing Environment inside Emacs
Don't forget to check out other packages that improve the actual content creation and writing texts in Emacs. [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]] is a good collection of articles. Different people have obviously different opinions and take different approaches. [[https://explog.in/notes/writingsetup.html][explog's wirting setup]] is probably a good starting point for any user. Jacob Moena's post on [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/][Creative Writing with Emacs]] provides a more comprehensive intro including some useful extra packages [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/#Extras][here]].

Personally, I think you have to try different packages and find the settings that is appealing to you and your use-case. But here are some suggestions based on my experience.
1. Toggle frame to full screen and hide all other Windows
2. Hide the =properties drawers= that are used for ox-hugo settings, by using =org-fold-hide-drawer-all=.
3. Use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][flyspell-mode]] for spell checking.

Put all of that in an interactive command, and can call it whenever you want to focus on writing:
#+begin_src emacs-lisp
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)
#+end_src
You can also add more settings to this function depending on your preferences. Here are some packages I suggest you try:
1. Consider [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] and [[https://gitlab.com/OlMon/consult-flyspell][consult-flyspell]] for better, more user-friendly interactive commands with flyspell.
2. Consider [[https://github.com/mhayashi1120/Emacs-langtool][Emacs-langtool]] for checking grammars etc.
3. Consider [[https://github.com/larstvei/Focus][Focus]] mode to get an effect similar to what WordPress calls spotlight.
4. Consider [[https://github.com/cyrus-and/zoom][zoom]] if you open multiple buffers and want the width to adjust dynamically
5. Try out other packages such as [[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] or [[https://github.com/sachac/artbollocks-mode][artbollocks-mode]].

Here is a screenshot of my setup with flyspell, olivetti and focus-mode.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/focus.gif]]


**** Bonus 4: Seeing Previews with =Hugo Server=
Obviously no good blog editor would be complete without a way to preview the post. If you use Hugo, you can see a preview by running =hugo server= in the terminal which fires up a local server (server default address is http://localhost:1313/). You can achieve the same by using a package like [[https://github.com/masasam/emacs-easy-hugo][emacs-easy-hugo]] from inside Emacs. However, that might be too overkill given that we can already do most of the functionality with org-mode and ox-hugo. Personally, I have defined a function that calls =hugo server= as a process within Emacs and a second function to kill the process.

#+begin_src emacs-lisp
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )
#+end_src

Note that the arguments =-buildDrafts= and =--navigateToChanged= are passed to =hugo server= to make sure you see your drafts and also automatically navigate to the most recent changes.
If you also have xwidget-webkit in your Emacs, then you may want to create another interactive command to open the page in a second buffer like below. If you don't have xwidget, you can use any other browsers for example by invoking =browse-url= to open the link in an external browser.

#+begin_src emacs-lisp
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src

This opens the local hugo server and navigates to the page for the post in the current buffer. Since we have =--navigateToChanged= turned on, as we edit the text we can see the changes right away. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/preview.gif]]


**** Putting everything together: Code and Screenshot

Here is a screenshot that shows the complete workflow:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/full_workflow.gif]]


and here is my preferred entire code (see the post for some alternatives if you don't have/want all the required extra packages below):

#+begin_src emacs-lisp

;; org-todo keywords
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))

;; org-todo faces
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))


;; function(s) to run on changing state
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)


(setq org-log-done 'time
      org-log-into-drawer t)

;; make sure org-todo keywords don't get exported
(setq-default org-export-with-todo-keywords nil)

;; capture function for blog posts
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))

;; custom org-agenda view
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))

;; enable extra packages for focusing on writing
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)

;; start the hugo server with Drafts and navigateToChanged
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

;; stop the hugo server process
(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )

;; get a preview of new drafts
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src


*** DRAFT Why scientists need a website?            :@software:@scientists:web:
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: why_scientists_need_a_web
 :EXPORT_FILE_NAME: index
 :TITLE: Why Scientists Need a Website
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle 
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary 
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'caption'
  focal_point: 'center'
#+end_src


*** DRAFT Consult-GH: Working with GitHub inside Emacs in 2023
:PROPERTIES:
:EXPORT_HUGO_DRAFT: true
:EXPORT_HUGO_SECTION_FRAG: Consult-GH:_Working_with_GitHub_inside_Emacs_in_2023_
:EXPORT_FILE_NAME: index
:TITLE: Consult-GH: Working with GitHub inside Emacs in 2023
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle Introducing a new package for using GitHub interactively inside Emacs based on Consult and Embark
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary This post introduces my new Emacs package that uses the fabulous Consult and Embrak along with GitHub CLI tool to create an intuitive user-friendly interface for GitHub inside Emacs
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
tage:
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

**** Introduction or some food for thought

***** What is the need? Why make a new package?
I often find myself going back to the same github pages for various reasons. Sometimes I go back to a package repo to read the documentation/manuals for installing or troubleshooting. Other times I browse the repositories by users whose works are of interest to me (for example [[https://github.com/purcell/emacs.d][Steve Purcell's Emacs Config]] or [[https://github.com/alphapapa][alphapapa (Adam Porter)]]'s packages for org-mode workflows). This is often done by doing a Google search finding the relevant GitHub Page and navigating from there to find the right content. It would have been great if I could do all of that from inside Emacs especially if I could then take some code from those repositories, paste it in an org-mode source block and see how it works. But, as far as I know, no emacs package provides a user-friendly intuitive interface for such functionality. While there are multiple packages that interface with github api like [[https://github.com/sigma/gh.el][gh.el]], [[https://github.com/magit/ghub][magit/ghub]], [[https://github.com/magit/forge][magit/forge]], [[https://github.com/sshaw/git-link][git-link]], [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] and ... None of them provide the kind of functionality I am looking for. Let's take a closer look at some of these to better understand why there is a need for something better. On one end of the spectrum, we have a package like [[https://github.com/sigma/gh.el][gh.el]] which seems to be an interesting option with a huge code base possibly covering a lot of low-level API calls to GitHub but there is not a single line of documentation on how to use it! The repo seems to be abandoned years ago, and the owner mentions on one of the issues that *"the whole thing was a gigantic experiment around the viability of eieio, and I'm pretty disappointed by the amount of suffering it generates, so I'm not sure I should push people to use it..."*  On the other end of the spectrum we have packages like git-link and browse-at-remote that are relatively small (<1000 lines of code) but the functionality is very limited, getting the URL links for files and commits, etc. While these are very useful, especially because they cover sources other than GitHub too, they don't really provide a way to browse repositories or issues. Then there is of course magit packages, that are indeed incredibly useful. magit/forge for example provides a great interface with issues and pull requests on multiple repository sources. However, this is geared toward repositories you actively work on and not so much toward browsing any random repository. Let's also not forget these packages were started several years ago, and since then there has been updates in Emacs as well as other tools like GitHub CLI that provide new opportunities for how we can interface with GitHub from inside Emacs. This is exactly what Consult-GH is trying to do.

***** What is the right way to address the need?
The principle idea behind consult-gh is that there is already tools that provide the basic functionalities for us and we can leave the heavy lifting part of the job to those and only provide the parts that are missing. For example, the GitHub CLI is the right tool to use for interfacing with GitHub. By leaving jobs such as authentication and api calls to =gh= command tools we simplify the code and make it really easy to setup and use. In addition we make the code more secure since we don't have to handle authentication tokens and secure information and at the same we keep it more maintainable because we don't have to worry about keeping up to date with the api. The official GitHub CLI will ensure that for us. For comparison, if you setup magit/forge and go through all the steps you need to do to interface with GitHub, you'll see while leaving this job to a tool like =gh= might be a better approach. On the other hand, =completing-read= inside emacs provides a perfect tool for interfacing with users and runing queries, etc. and in the recent years, there has been great improvements especially with a package like [[https://github.com/minad/consult][consult]] that wraps aeound completing read and provides easy to use functionalities. Along with the rest of completion framework packages ([[https://github.com/minad/vertico][vertico]], [[https://github.com/oantolin/embark][embark]], [[https://github.com/oantolin/orderless][orderless]], ...) it provides a great toolset for functions that need input form users. Therefore by bringing =consult= and =gh= together, we can easily provide a concise yet powerfool tool that improves on the current alternatives for interacting with GitHub inside Emacs. That said, let's keep in mind that the goal here is not replace the existing functionalities with yet another tool but fill the gaps between the current tools. For example, consult-gh does not provide (at least not yet) a way to edit issues or pull requests because that functionality is available in magit/forge for not just github but also other sources so I don't see any benefit in yet another tool for it.

   we should leave the main jobs to functionalities and allows achieving great functionality with a minimal code base (currently less than a 1000 lines of code).   behind consult-gh that makes it what it is:


However,the workflows are often highly customized and specific, and naturally it is difficult to come up with a one-size-fits-all solution and practically speaking going back to the browser becomes the natural choice again.

As shown above, Consult-GH tries to balance between usability (a.k.a. having many commands) and utility (being practically more efficient for custom work flows) by providing *only a handful of interactive commands* to keep things simple, intuitive and and easy to use, but offering a range of customization to tweak the behavior so that the user can pick what is most useful in their common work flows. For example, =consult-gh-search-repos= simply returns possible matches for the search term and allows the user to customize the default action when a repository is selected. Whether that is opening the url in a browser, or viewing the README in an emacs buffer, or cloning the repository, it's up to the user to pick what is the default action. If the user needs more than one action, then they can use the [[https://github.com/oantolin/embark][Embark]] integration.

In this section I'll showcase some interesting examples that I find useful and efficient enough that is now my first choice for interacting with GitHub as opposed to using a browser.

**** Can you show me examples on how this is useful?
***** Following the users I like
There are a few GitHub accounts that I tend to keep going back to both for  finding new interesting work and also for learning from their code and approach. Before making Consult-GH My work flow was to do a goole search for example for "emacs operating system" or "steve purcell emacs config" and then finding the github page and browsing through recent updates and changes, etc. This is not very efficient because syntax highlighting inside a browser is sub par and there is no help/docs inside a browser, but if this is done inside Emacs, helps and documentations are just a "C-h key" away and subsections of the code can be evaluated for example inside an org-mode source block to probe the behavior and functionalities. Of course the question is how do you get [[https://github.com/purcell/emacs.d/][Steve Purcell's Emacs Config]] inside emacs without going to the browser. You can of course keep a local copy by cloning the repository and then pulling the latest updates every time you want to browse it, but that would waste some space on your local drive and often times you might not be interested in the whole repo anyway. In other cases, you may want to see people's new work, e.g. new repositories, and without knowing the name and links of the repo, you still have to go to the browser to find those. Consult-GH provides an easy way to see the repositories from people you want to follow and quickly browse single files or clone entire repositories.

As seen in the screenshot below, the command =consult-gh-orgs= allows you to search GitHub users and see their repositories. Importantly, you can also search for multiple users at the same time. By default your search history is saved and accounts but only the search terms that produce any results will be stored in =consult-gh--known-orgs-list=. As  a result you will have quick access to user accounts you have looked up before, and if you want to preserve that between emacs sessions, you can turn =savehist-mode= on and add =consult-gh--known-orgs-list= to =savehist-additional-variables=:

#+begin_src emacs-lisp
(add-to-list 'savehist-additional-variables 'consult-gh--known-orgs-list)
#+end_src


***** Features and Examples
More often than looking for specific users, I have to look up specific packages (e.g. org-roam, lsp-mode, ...) to check manudals and documentation. This would have been done with Google and browing GitHub before Consult-GH, but now I prefer consult-gh because it is much faster and more efficient for my work flows. There are important features that make this more efficient and I am going to showcase some of the important ones for a typical work flow below. I will use an example and will show you configurations and screenshots of how you cna do each.

Let's say I want to look up a repo (such as org-roam, or ox-hugo) but I don't remember the name of the user/org on GitHub, so instead of looking up the user, I run the interactive command =consult-gh-search-repos= and search for them. In case of =org-roam= the first result is ="org-roam/org-roam"=. From here I can run a range of different functions depending on what I want to do. Here are some examples:

****** previewing a single repo
By default, previews are off because previewing a repo requires downloading the README file and that can be slow depending on your environment and network speed, etc. But in my config, I have turned consult-gh's previews on. I have also set the preview-mode to ='org-mode=. By default this is set to ='markdown= to preserve the contents since most README files are =.md= format but I trun it to org-mode because this makes it much easier for me to see source-blocks, etc. and evaluate them inside Emacs.

#+begin_src emacs-lisp
(consult-gh-show-preview t)
(consult-gh-preview-buffer-mode 'org-mode)
#+end_src

With this setting, when I move the cursor to ="org-roam/org-roam"= in minibuffer I see the README in org format in a preview buffer and I can and read the contents, evaluate source blocks, etc. without leaving Emacs.

****** Seeing the files contents of a repo
Now if I hit enter to select this repo, then the default action function that is bound to the variable =consult-gh-repo-action= is run. By thedefault this is bound to the function =consult-gh--repo-browse-url-action= which opens the github page in the browser. This is again to optimize the performance, but if performance is not a concern, you can change the default function to something more useful for your work flow. Personally, I have changed it to =consult-gh--repo-browse-files-action= which allows me to browse the files inside Emacs. Here is my config
#+begin_src emacs-lisp
(consult-gh-repo-action #'consult-gh--repo-browse-files-action)
#+end_src

Note that this only fetches the file tree and does not download the files until you open the file (or a preview buffer). This way, you will only download the contents you want to see. Also, the files are stored in the system's default temporary directory so once you restart your computer, the space that is used to store the files is restored. Moreover, in a resource-limited environment where performance is of concern, you can turn the preview on but enable it on demand by setting the =consult-gh-preview-key= to a key binding like the code below

#+begin_src emacs-lisp
(setq consult-gh-show-preview t)
(setq consult-gh-preview-key "M-o")
#+end_src

The code above turns the preview on for consult-gh but sets the preview key to ="M-o"=, so you can see the preview of a file or repo when you hit ="M-o"=. This is likely the ideal setup for both performance and usability.

****** Additional commands to run on a repo such as cloning or forking
In addition to seeing the file contents, you may want to run other commands such cloning a repo or copying the url link to kill-ring or ... These commands are provided as separate functions that can also be bound to the default repo action or alternatively can be used by the consult-gh-embark integration. The consult-gh-embrak.el provides some examples of how to set embark up for this. In the screen shot below you can see me cloning a repository by using embark. You can also define other custom functions and bound them to the embark keymap following the same patterns as those provided.

There are some additional functions provided for example to view the issues or to copy relevant links (homepage, https or ssh links for cloning, and and org-mode link) to kill-ring. In addition I provide an example that copies a drop-in snippet with =straight.el= and =use-package= to kill ring. I can paste this snippet in my emacs config to install the package! As you can see, this is very flexible and you can append the embark actions following the built-in examples provided to create any other custom work flow you need.

****** Commands to run on files
Similarly to what was mentioned for repos, you can also run different functions on files. By default consult-gh opens the file url on github when you select it, but you can configure it to open the file in emacs in the appropriate major mode. This makes an API call and downloads the file contents, so it may be slow for large files but in my tests so far the speed has been great even for some large files. Here is a configuration to will set consult-gh to open files inside emacs.

#+begin_src emacs-lisp
(consult-gh-file-action #'consult-gh--files-view-action)
#+end_src

As mentioned above, previewing a file will also fetch the contents and therefore you may want to limit previews to on-demand only by setting a preview key.

Similar to what I said for repos you can use other funcitons such as =consult-gh--files-save-file-action=  to save a file locally as opposed to opening it in a temporary buffer. This might be especially of interest if you are selecting multiple files (see below).


****** Working with multiple repos or files
Moreover the integration with embark allows some more complex functionalities such as working on multiple repos or files. Let's say I want to look at all the repos by alphapapa and clone a few of them that are related to org-mode. Now since alphapapa has over 700 repositories in his account, I first need to increase the maximum number of results I normally get:

#+begin_src emacs-lisp
(setq consult-gh--repo-maxnum 1000)
#+end_src

Then I can run =consult-gh-orgs= and look for =alphapapa=. This takes some time to load all the repositories but this is way faster than browsing through GitHub to find the repositories manually. Then in the result I search for ="org-"= and run embark select (in my case this is bound to SPC so in my case this is ="C-. SPC"=) and ocne I select everything I am
looking for, I run embark act on all ("C-. A") plus the consult-gh-embark-repo-clone (bound to "c" in my setup). By default, consult-gh wil lgo through every repository and confirms the repo I want to clone and the path, etc. But if you happen to do this often, you can configure consult-gh to always clone the repositories in a folder where you kep your repositories (e.g. "~/code" or "~/projects") and then set =consult-gh-confirm-before-clone= to nil:

#+begin_src emacs-lisp
(setq consult-gh-default-clone-directory "~/code")
(setq consult-gh-confirm-before-clone nil)
#+end_src

With this setting consult-gh just clones the repositories with the repo's default name under ="~/code"= folder. Browsing GitHub in the browser or using gh in the command line will never be this fast!

Similarly you can use embark-select and embark-act-all to run commands on multiple files possibly even from different repos or from different branches of the same repo.

For example in the screenshot below I download the README files from two different repos vertico from minad and selectrum from radian software accounts.



One interesting example is to run a diff on the same file in two different branches of the same repo withouc cloning the repo and runing git diff. In the screen shot below, I search for the repo "minad/consult" then I select it twice (separated by my default crm-separator in this case ",") and select two different branches, then I see the file trees for the two branches. I search for a file (e.g. "README")that narrow downs the items in both branches and I select the and I open previews for both branches by hiting "M-o". Now I have both files in an open buffer. I quit consult-gh and run vdiff-buffer and select the two buffers visiting those files. Of course you can achieve this by cloning the repo and running git diff but this is much faster especially if you don't want to clone the entire repo.


****** Viewing Issues
In addition to repos and files, you can also browse issues with =consult-gh-search-issues=. You then need to select a repo or possibly multiple repos and enter a search term. If you want to see all the issues you can pass an empty string to the search term. You can set the =consult-gh--issues-state-to-show= to =open=, =closed= or =all= to change the issues that are shown. Note that this is different from the behavior of =gh search issues= in the command line where you only have the option =open= or =closed=. Similar to what was mentioned for repos, and files you can then run different actions on issues. By default the action is set to =consult-gh--issue-browse-url-action= that opens the url in a browser but you can also change that to =consult-gh--issue-view-action= to see the issue inside an emacs buffer.


**** Future Ideas
There are a few other ideas that i have in mind and I may implement them in the future as time allows and would welcome anybody that would like to contribute to these or potentially other interesting ideas:

1. I would like to provide a simple interface for multiple profiles. This should be easily achievable using enviroment variable like GH-CONFIG-DIR, but I still need to decide what would be the right way of implementing it. Should be a global variable in consult-gh or shall we dfine local pe buffer variables, etc.

2. I think we can improve the current interface of =consult-gh-find-file= to make it behave more like find-file in emacs where folders are expanded dynamically as the user makes step-by-step selections to navigate the folders. This is however not the best approach for looking at files in multiple repos, so I may have to keep the current aproach for multiple repos, but I'd love to hear suggestions on that. I briefly talked to minad (the owner of the consult repo) and it seems that there are good ways of implementing a dynamic completion table for file-names with consult. But so far between my limited elisp skills and lack of good in-detail documentation on emacs completion tables, I have only had partial success with it and there are still many quirks to deal with. So this may take some time to implement.

3. The =gh= command in the terminal provides additional arguments to further filter search results for example to filter issues by date or tags, etc. This is not yet implemented in consult-gh. I think it can be added by some minimal effort if I enable extra arguments in some of the calls to gh (that I can of course turn into a rabbit hole that takes weeks but I think it'd be doable at the end anyway). However, I am not yet convinced that this will add much value. I think having too many options can negatively affect the user-friendliness and efficiency of the package. There is always going to be some use-cases where jumping to the browser would be a better option after all. I'd be interested to hear counter arguments if any though especially if there are ideas for clean and simple interface that allows using such options with an intuitive interface.




That converts markdown-files to 'org-mode
you can trun previews on if I select that, it will open the GitHub page in the browser, but in my setting, I have changed the default action for repos to =#'consult-gh--repo-browse-files-action= that means when I select a repo, a new minibuffer menu opens and allows me to browse file contents of the repo. Furthermore I can customize consult-gh to open the "HEAD" branch, ask me to select the branch, or confirm whether I want to open "HEAD" or select another branch (This last option is useful for browsing multiple repos, see below).  So with this setting, I have quick access to files in any repositories from within Emacs.





 quick way to evaluate parts of the code and understand the behavior. Also no help available in a browser


 For an example I would search for




* fa
:PROPERTIES:
:EXPORT_LANGUAGE: Farsi
:EXPORT_HUGO_SECTION_FRAG: fa
:END:

** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH شروعی ساده
CLOSED: [2023-02-09 Thu 12:01]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: شروعی ساده
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle در مورد وبسایت و وبلاگ 
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary «معرفی وبسایت»
:END:
#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'This is an art made by midjourney AI and Armin'
  focal_point: 'center'
categories: ["نرم افزار", "طراحی وب", "درباره"]
#+end_src

**** *در چند جمله*
من اخیراً تصمیم گرفتم وبسایت قدیمی خود را بازطراحی و احیا کنم و در ادامه تصمیم گرفتم که از این پس نوشته های پراکنده خود را به صورت پست های وبلاگی در همین وبسایت منتشر کنم. به احتمال زیاد موضوعات پستها طیف متنوعی خواهند داشت اما سعی میکنم بیشتر به حوزه تخصص خودم به ویژه تکنولوژی سلامت بپردازم. همچنین دوست دارم تجربیات خودم را در استفاده از ابزارهای نرم افزاری به اشتراک بگذارم، به عنوان مثال پستهایی مثل "چگونه از emacs و ox-hugo برای نوشتن وبلاگ استفاده کنیم" یا "استفاده از NLP و python برای استخراج اطلاعات فنی از گوگل پتنت" و ...

****  *چطور همه چی شروع شد*

من برای اولین بار در سال ۱۳۹۱ شروع به طراحی این وب سایت کردم. در آن زمان، من در دانشگاه درکسل در آمریکا دانشجوی دکترا بودم و در حوزه نانوحفره های مصنوعی به عنوان حسگرهای زیستی مشغول به مطالعه و تحقیق. من می‌خواستم وبسایتی بسازم تا مجموعه تحقیقات و علایقم را به نمایش بگذارم و در این فرآیند درباره طراحی وب، «HTML» و «CSS» نیز اطلاعات بیشتری کسب کنم. وقتی متوجه شدم که می‌توانم وبسایت خود را در فضای صفحه وب شخصی دانشگاه درکسل میزبانی کنم، این پروژه به سادگی شروع شد. پس از تحقیقات اولیه، فکر کردم خوب است که وب سایت را بدون اسکریپت (یعنی فقط با «HTML» و «CSS») طراحی کنم و در عین حال فقط از کار خودم استفاده کنم به این معنی که همه چیز از عناصر طراحی (لوگوها، دکمه ها و غیره) تا بلوک های «HTML» ساخته خودم باشد و نه کار شخص دیگری [fn:کارخودم]! اولین پیش نویس طرح در چند روز آماده شد، اما طراحی و کدنویسی کمی طول کشید، به خصوص به این دلیل که باید CSS را از ابتدا یاد می گرفتم و اجرای طرح اولیه ساده نبود، چرا که از شش ضلعی و حاشیه های مورب استفاده می کرد (برای مثال این [[https://archive.armindarvish.com/research.html][لینک]] ببینید) ، که به راحتی قابل اجرا نبود به خصوص اینکه فقط از «HTML» و «CSS» استفاده می کردم. اولین نسخه در سال ۱۳۹۲ منتشر شد و کمی پس از آن نسخه اولیه فارسی  را به وبسایت اضافه کردم. اما در همین حین، من درگیر تحقیقات دکترای خود شدم و به روز نگه داشتن وبسایت با دو زبان بیشتر از آنچه پیش بینی می کردم وقت میبرد، بنابراین پیشرفت کار کند شد. سپس در اواسط سال ۱۳۹۵ فارغ التحصیل شدم و به کالیفرنیای شمالی نقل مکان کردم تا برای یک شرکت کوچک و نوبنیان کار کنم،  جایی که روزانه به طور متوسط ​​بین ۱۲ تا ۱۴ ساعت وقت می‌گذاشتم [fn:کارزیاد].بنابراین دیگر فرصتی برای کار بر روی پروژه های شخصی از جمله این وب سایت نبود. این نسخه از وبسایت را میتوانید در این [[https://archive.armindarvish.com/index_fa.html][لینک آرشیو]] ببینید.

**** *شروعی تازه*

این پروژه پس از آن برای چند سال بدون به‌روزرسانی رها شد تا اینکه من نهایتاً در سال ۱۳۹۸، تصمیم گرفتم شرکتهای نوپا و ساعات کار طولانی آنها را ترک کنم و به یک شرکت بزرگتر و پایدارتر با ساعات کاری انسانی‌تری بپیوندم. در نتیجه یک بار دیگر این فرصت به وجود آمد که به کار بر روی پروژه های شخصی از جمله این وب سایت بپردازم.  یک بار دیگر فرصتی برای بررسی پروژه‌های شخصی پیدا کردم و تصمیم گرفتم این وبسایت را احیا کنم. ایده احیای وبسایت با این واقعیت که دانشگاه درکسل تصمیم گرفت سروری را که میزبان وبسایت اصلی من بود خاموش کند تقویت شد.در ادامه تصمیم گرفتم که از یک زنجیره ابزار جدید استفاده کنم، زیرا نگهداری وب سایت قدیمی با «HTML» و «CSS» آسان نبود، به علاوه این فرصت خوبی بود برای اینکه دوباره ابزار و مهارت های جدیدی را یاد بگیرم. بعد از کمی تحقیق، تصمیم گرفتم که از[[https://gohugo.io/][«Hugo»]]، به همراه [[https://www.github.com/][«GitHub»]] و [[https://www.netlify.com/][«Netlify»]] استفاده کنم، و بعد از دیدن نمونه های مشابه (مثل این [[https://www.aidanscannell.com/][صفحه]]) و توصیه ها و راهنماهای آنلاین (مثل [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][اینجا]])، تصمیم گرفتم از طرح [[https://academic-demo.netlify.app/][«Academic»]]  از [[https://wowchemy.com/][«wowchemy»]] استفاده کنم و نتیجه همین شد که میبینید.

**** *پس از این*

با استفاده از زنجیره ابزار جدید، به روز رسانی این وب سایت بسیار آسانتر شد. در واقع به روزرسانی آنقدر آسان شد که تصمیم گرفتم می توانم یک وبلاگ هم به این پروژه اضافه کنم. پیش اط این من یادداشت‌های پراکنده‌ای را اینجا و آنجا در پلتفرم‌های رسانه‌های اجتماعی مختلف منتشر کرده بودم، اما اکنون می‌خواهم همه چیز را اینجا در وب‌سایت خودم نگه دارم. هدف جدید من در این پروژه این است که عادت کنم به نوشتن پست های کوتاه در مورد موضوعات جالب و ساخت مجموعه ای از افکار، ایده ها، یادداشتها و دستورالعملهایی که به مرور جمع آوری میکنم. احتمالاً در مورد موضوعات مختلفی که به آنها علاقه دارم مانند بیوتکنولوژی، نانوحسگرها و تکنولوژی سلامت خواهم نوشت. همچنین دوست دارم که تجربه خودم از استفاده از  ابزارهای نرم افزاری مانند استفاده از «emacs» مثلاً برای ایجاد همین پست و یا نحوه استفاده از «midjourney» برای ایجاد پس زمینه های جالب برای وب سایت خود، یا استفاده از «python» و «NLP» برای استخراج اطلاعات فنی از پتنت های گوگل و ... بنویسم.

در حالی که این یک وبلاگ چند زبانه خواهد بود، همه پست ها به همه زبان ها در دسترس نخواهند بود و نوشته های فارسی لزوماً ترجمه نوشته های انگلیسی نیست. افکار، تجربیات و شاید حتی شخصیت من در محیط هایی با زبان های مختلف یکسان نیست و بنابراین، مطالب پست های من نیز انعکاس این تجربیات خواهند بود.



* Footnotes
[fn:mywork] The only exception was the map widget

[fn:کارخودم] البته به جز بعضی المانهای خاص مثل نقشه!

[fn:کارزیاد]توصیه میکنم که این حد از کار را به هیچ عنوان تجربه نکنید چون برای جسم و مغز و روح و روانتون مضره!

[fn:Netlify]Note to self: write another post about choice of tools and how to build a website with hugo, github and netlify!

[fn:longwork] I Don't suggest trying that yourself. It's not good for your physical or mental health!


#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'headline
          (lambda (hl)
            (when (string-equal (org-element-property :raw-value hl) "Humble Beginnings")
              (org-element-map (org-element-contents hl) 'paragraph
              (lambda (paragraph)
                (insert paragraph)
              )))))



#+end_src

* COMMENT Local Variables                                             :ARCHIVE:

# Local Variables:
# eval: (org-hugo-auto-export-mode t)
# eval: (my:blog-minor-mode +1)
# End:
