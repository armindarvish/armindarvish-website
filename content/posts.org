#+OPTIONS: author: nil
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_lastMod: t
#+hugo_front_matter_format: yaml

* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH Humble Beginnings                  :@software:@webdesign:@about:
CLOSED: [2023-02-09 Thu 11:49]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: Humble Beginnings
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle About this Website and Blog
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary The totally necessary "about this blog..." post to introduce this website and blog
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption: 'This art was generated by AI and /\\r|\\\\/|i|\\\\|'
  focal_point: 'center'
#+end_src
**** *TLDR*
I recently decided to redesign and revive my old website and in the process, I decided that I would like to make a habit of writing blog posts here on my own websites. I'll likely be covering a range of topics mostly around research especially in healthcare technology. I'll also share my experience with software tools and workflows for example "How I am using emacs and ox-hugo to write this post" or "using NLP and python to extract interesting information from patents" and ...

**** *How it all started*
I first started working on this website back in 2013. At the time, I was a PhD student at Drexel University working on solid-state nanopores biosensors. I wanted to make a website to showcase my research portfolio and interests and in the process learn more about web design, HTML and CSS as well. I figured I could host it on Drexel's personal web pages and that's how this project simply started. After some initial research, I thought it would be nice to make the website script-free (only HTML and CSS) and only use my own work meaning that everything from design elements (logos, buttons, etc.) to HTML blocks had to be my own creation and not someone else's work[fn:mywork]! The first draft of the design was ready in a few days, but design and coding took some time especially because I had to learn CSS from scratch and my design was tricky to implement because I had hexagons and diagonal borders (see this [[https://archive.armindarvish.com/research.html][link]] for example) which was not straightforward, especially with HTML and CSS only. The first version was published later in 2014 and soon after I added a skeleton for my native-speaking language, Farsi. However, in the meanwhile I got very busy with my PhD research and keeping everything up to date with two languages was simply more work than I anticipated, so the progress slowed down. I then graduated in the middle of 2016 and moved to Northern California to work for a small start-up, where I found myself spending an average of 12–14 hours a day at work[fn:longwork]. That left me with no time to work on any personal projects including this website. You can see the old design in [[https://archive.armindarvish.com/][archive]].

**** *A New Beginning*
The project was abandoned for years with no updates while I was working for start-up companies in Silicon Valley. Then in 2019, I decided to leave the start-up scene and its ridiculously long working hours for greener pastures in a bigger, more stable company with more humane hours, and once again I found some time to consider personal projects and decided to bring this website back alive. The idea was further reinforced by the fact that the hosting server I was using was shut down by Drexel University. I decided it would be better to use a whole new set of tool chain, since the old website with HTML and CSS was not easy to maintain, plus the fact that this was again a good opportunity to learn new tools and skills. After some brief research I decided that I want to use [[https://gohugo.io/][Hugo]] combined with [[https://www.github.com/][GitHub]] and [[https://www.netlify.com/][Netlify]][fn:Netlify], and after some more browsing, looking at other people's examples (e.g. [[https://www.aidanscannell.com/][Aidan Scannell's Page]]), and reading online instructions (like [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][this one]]), I decided to give [[https://academic-demo.netlify.app/]["Academic Theme"]] from [[https://wowchemy.com/][wowchemy]] a try and the result is what you are looking at.

**** *Going Forward*
CLOSED: [2023-02-09 Thu 11:47]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:END:
Using Hugo and Netlify, made it really easy to update my website in more than one language as well. In fact it is easy enough to update that I have decided I can keep a blog here. In the past I have written scattered notes here and there on different social media platforms but going forward I'd like to keep everything here on my own website. My new goal in this project is to make a habit of writing short posts on interesting topics and build a collection of thought, ideas, tutorials over time. I will likely write about various topics I am interested in like biotech, nanosensors, and healthcare technology.  In addition, I will be writing posts on some software tools like interesting work flows in emacs including the one I am using to make this very post right now or how to use midjourney to make interesting backgrounds for your website, or using python and NLP to extract detailed technical information from Google Patents, and ...

While this is going to be a multilinqual blog, not all posts will be available in all languages.  My thoughts, experiences and perhaps even my personality is not always identical in environments with different languages, and therefore, the contents of my posts will reflect that reality. 


*** PUBLISH Emacs Workflow: Dynamically Adding Files to Org Agenda :@software:@emacs:@orgmode:
CLOSED: [2023-05-22 Mon 10:32]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files
:EXPORT_FILE_NAME: index
:TITLE: dynamically adding files to org-agenda-files in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to automatically and dynamically build org-agenda-files to include any files with TODO items.
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I'll show you my workflow for automatically adding files with TODO items to org-agenda-files as soon as we open or save the file.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src


**** Intro

If you use Emacs org-mode for task management, you have probably wondered if there is a way to dynamically add files with TODO items to org-agenda-files. A Google search will likely get you some initial ideas on how to do it. For example this post: [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][Boris Buliga - Task management with org-roam Vol. 5: Dynamic and fast agenda]] covers how to this. But since Boris's post focuses on using org-roam, it may not be the right solution when you use org-roam. So I had to hack my own solution and in this point I'm going to share that with you in case anyone is interested. You can see a [[file:en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamic_org_agenda.gif][screenshot]] below.


**** How does it work

For the main functionalities, I am using [[https://orgmode.org/worg/dev/org-element-api.html][Org Element API]] to parse org-mode buffers and find org TODO items. If there is a =TODO= item in the buffer, and it is visiting a file, I add the file to =org-agenda-files=. Additionally, I make sure that =org-agenda-files= is remembered between different Emacs sessions, I add =org-agenda-files= to =savehist-additional-variables=.

Then I define custom functions for and add them as hooks to org-mode to update =org-agenda-files= when an org-mode file is opened as well as when an org-mode file is saved. The redundancy helps make sure that nothing is lost if there is a crash.


**** The code

- Check if the file contains a =TODO= item:

 Use =org-element-map= and =org-element-parse-buffer= to walk the buffer, find all headlines and return true if there is any headline that is a =TODO= item. Note that I am looking for any heading that is a =TODO= item. Alternatively you can check for specific =TODO= types by looking at =:todo-keyword= instead of =:todo-type= e.g. =(org-element-property :todo-keyword h)...=

#+begin_src emacs-lisp
(defun ad/agenda-file-p ()
    (org-element-map
       (org-element-parse-buffer 'headline)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match))
#+end_src

- make a custom function to update =org-agenda-files= if the current org-mode file contains a =TODO= item:

If the current buffer contains a =TODO= item, I use seq-difference to find out if the files are already in org-agenda-files. If it does not contain =TODO= item, I make sure to remove it from =org-agenda-files=. This is important because when I'm done with a =TODO= item and remove it from the file, I would want the file to be removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-update-files (&rest ARG)
  ;; check if this is an org file buffer
  (interactive)
    (when (and (derived-mode-p 'org-mode) (buffer-file-name))
      (message "updating org-agenda-files...")
      ;; if there is an active TODO task, add this file to agenda files
      (if (ad/agenda-file-p)
      (add-to-list 'org-agenda-files (file-truename (buffer-file-name)))
      ;; if there is no active TODO task, remove the file from agenda files if needed
      (setq org-agenda-files (seq-difference org-agenda-files (list (buffer-file-name))))
      (customize-save-variable 'org-agenda-files org-agenda-files)
      ))
      )

#+end_src

- cleaning up =org-agenda-files= and remove files that don't exist anymore.

When I delete some files, I want to make sure it gets removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-cleanup-files (&rest ARG)
  (interactive)
  (let ((temp/org-agenda-files org-agenda-files))
  (dolist (file org-agenda-files)
  (if (not (file-exists-p file))
      (setq temp/org-agenda-files (seq-difference temp/org-agenda-files (list file))))
    ())
  (setq org-agenda-files temp/org-agenda-files))
  )
#+end_src

- Adding hooks

To get my functions to run automatically, I add =hooks= to =org-mode=. I make =lambda= functions that are added as hooks to =find-file-hook= and =before-save-hook= to make sure that =org-agenda-files= gets updated whenever I open an org-mode file and then again when I save the file.

#+begin_src emacs-lisp
;; Add or remove individual file
(add-hook 'org-mode-hook (lambda () (add-hook 'find-file-hook #'ad/org-agenda-update-files)))
(add-hook 'org-mode-hook (lambda () (add-hook 'before-save-hook #'ad/org-agenda-update-files)))
#+end_src

- Adding advice to functions that use =org-agenda-files= to show =TODO= items.

Before I run =org-agenda= or =dashboard-get-agenda=, or any other function that reads =org-agenda-files= to show my =TODO= items, I need to make sure to remove non-existing files from =org-agenda-files=.

#+begin_src emacs-lisp
;; remove non-existing files before building agenda
(advice-add 'org-agenda :before #'ad/org-agenda-cleanup-files)
(advice-add 'org-todo-list :before #'ad/org-agenda-cleanup-files)
(advice-add 'dashboard-get-agenda :before #'ad/org-agenda-cleanup-files)
#+end_src

- Make sure =org-agenda-files= is remembered between Emacs sessions.

I add =org-agenda-files= to =savehis-additional-variables= and make sure that =savehist-mode= is enabled.

#+begin_src emacs-lisp
(add-to-list 'savehist-additional-variables 'org-agenda-files)
#+end_src

**** Performance
Of course adding files dynamically to the =org-agenda-files= comes with a cost. Make too many files with org-agenda items and it will be very slow. Personally I keep most of my general =TODO= items in one file under my main org directory and only put =TODO= items in other files when having it in the context of the specific project is useful.

**** Screenshot

Here is a screenshot showing it in action. I open an org file and a =TODO= item in it and save it and as you can see once I refresh the buffer describing =org-agenda-files= variable, the new file is added to the list. I also show that once I remove the =TODO= item or mark it as DONE, it is automatically removed from the list. Also, you can see that once I have the new file in the org-agenda list, it automatically shows up on my dashboard.

#+ATTR_ORG: :width 800px :height nil px
#+ATTR_LATEX: :width 800px :height nil px
#+ATTR_HTML: :width 800px :height nil px
[[file:~/projects/armindarvish-website/content/en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamics_org_agenda.gif]]

*** PUBLISH Building the Best Blog Editor with Emacs Org-Mode in 2023?
CLOSED: [2023-06-20 Tue 01:23]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Building_An_Efficient_Blogging_Workflow_in_Emacs
:EXPORT_FILE_NAME: index
:TITLE: Building An Efficient Blogging Workflow in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to use org-mode and ox-hugo along with org-todo items and org-agenda to manage your blog posts
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I will show you my custom workflow in Emacs for writing blog posts. I use org-mode for writing the text and ox-hugo for exporting to markdown files. The post focuses on how to create a custom workflow starting with capturing the initial idea with org-capture, then using org-todo and org-agenda to track the post as you take it from idea to an initial draft through different stages of editing to finally publishing it on your website.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
categories: ["software", "emacs", "org mode", "blogging"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
#+end_src

In the previous post, I showed you how to automatically add files to your org-agenda. In this post I am going to expand on that and show you how to use =org-todo= items beyond tasks and todo lists and build custom workflows. As an example, I am going to show you my blogging workflow. This is what I am using right now to write this post, and in my opinion, it showcases the true power of Emacs and org-mode. If you want to know why Emacs is the one of the best tools for writing blogs in 2023, read on.

But before we get down to the point, let me make one thing clear: This is not a post about the basics of Emacs or org-mode and won't be giving you any configurations for writing text in Emacs either (although I will share some tips and tools as needed), instead it focuses on creating efficient workflows with automation using org-mode features that make Emacs superior to other available tools. Specifically I will show you:
1. Dynamic org-capture templates using Yasnippet snippets
2. Defining functions that are auto-triggered when an org-todo keyword is changed.
3. Some tips on custom org-agenda views to only look at items in a specific workflow
4. Extra tips for improving the look and feel and creating an intuitive user-friendly experience in org-mode
If you don't know much about Emacs or org-mode, or all you are looking for is a list of packages and settings that are useful for wiring non-programming text in Emacs, then I suggest to start elsewhere (You can find lots of good resources here:  [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]]) and come back to this post later, when you feel the need to take your workflow to the next level.

Also, note that while I am using a blog post as an example here, this general approach can be applied to many other scenarios, for example a bunch of flash cards you want to memorize; a selection of books you want to read, digest or summarize; a list of companies you want to apply for a job at; a bunch of projects you want to work on; and so on.

**** Using =org-todo= keywords
By default [[https://orgmode.org/][Emacs Org mode]] comes with two =org-todo= keywords ="TODO"= and ="DONE"= but you can add any custom keyword and use them to track different objects and category of items such as notes, flashcards, ideas, drafts, etc. You can do this by adding the labels to =org-todo-keywords= in a sequence following [[https://orgmode.org/manual/Workflow-states.html][Workflow states (The Org Manual)]]. For example for a blogging workflow I use =(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)")= as shown below. Note that by putting *PUBLISH* after "|", we are setting *PUBLISH* as the done label for this workflow, which can be used for other useful functions such as logging time, etc. (see the section on automating workflow [[Automating the Workflow][below]] for how I use it to automate logging times).

#+begin_src emacs-lisp
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))
#+end_src

Now, we can label org headings as a blog post by adding *DRAFT* todo keyword. This will serve as an entry point to capture ideas for a blog and add it to my agenda to edit later. As I edit the post and decide to publish it on my website, I'll change the label to *POST* or *PUBLISH*. I am going to show you how to use this to create some automated workflow but before that I am going to introduce another tool, Ox-Hugo, that makes it easy to write blog posts in org-mode if you use the static site generator, [[https://gohugo.io/][Hugo]].

**** Ox-Hugo
Next, we look at [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] that allows you to export texts written in org-mode to markdown files that are used by the [[https://gohugo.io/][Hugo]] static generator. If you use Hugo to build your blog, and want to write your posts in org-mode (which you should!), then [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] is a natural choice. There are other options such as =org-publish= as well, but I think Ox-Hugo is a better approach.

I recommend you go through Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]] for setting it up and find the specific settings that fit your need. But here are some ideas and tips to consider:

You can organize your blog posts either in separate files (one post per file) or all in one file under different org headings (one post per heading). Personally I am using one post per heading right now because I like to see all my posts in the same file next to each other. But if you prefer having the blog posts in different files, then you may want to consider my previous post [[https://www.armindarvish.com/en/post/emacs_workflow_dynamically_adding_files_to_org-agenda-files/][to dynamically add files to org-agendas]] so that every file gets added to your =org-agenda-files= automatically. Then you can use org-agenda views to browse through all your posts (see [[Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda][below]] for more on that).

Currently, I am using [[https://wowchemy.com/templates/][Wowchemy]]'s [[https://academic-demo.netlify.app/][Academic]] template for my website, so in my ox-hugo configuration, I set everything up according to the structure defined by that template. I use one org file for all my blog posts, and since I have a multilingual site, I put this file in my hugo website's folders under content alongside separate folders for each language. I then set up my ox-hugo to save each post in the appropriate folder by setting =:EXPORT_HUGO_SECTION_FRAG:= property. Because the properties are inherited, I can then use the same property in the subheadings of each post to point ox-hugo to save the post in the appropriate folder. For example for English posts I have something like the following in my file. As you can see I also add =YAML= source blocks for Wowchemy's settings following the documentation here: [[https://wowchemy.com/docs/][Hugo Documentation for Wowchemy]].

#+begin_src org
,* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
,** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

## Here I enter new posts##

,* DRAFT Title of the post

:PROPERTIES:
:EXPORT_HUGO_DRAFT: true
:EXPORT_HUGO_SECTION_FRAG: Title_of_the_post
:EXPORT_FILE_NAME: index
:TITLE: Title of the post
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle subtitle goes here
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary summary goes here
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [project]
categories: [tags]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
,#+end_src

#+end_src

I have a separate similar heading tree for other languages. With this setup I can use org-export with ox-hugo to automatically make the markdown files for each post.
Also, since my website is in a git repository, I keep a symlink copy of that file somewhere more convenient in my home folder such as ="~/blog/"= so I can quickly find my posts without navigating through the folder structure of my website.

Other than that there are some site-specific settings that I define in =:PROPERTIES:= drawers following Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]]. I also set up [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][auto export on saving.]]


**** Automating the Workflow
While the setup above is already great for writing posts in org-mode and quickly exporting them to markdown, we can do much more with org-mode =TODO= items. For example, we can create some automation flow by hooking functions to =org-after-todo-state-change-hook=, so your draft turns into a post on your hugo website automatically when you change the keyword. As a result, you can just focus on writing the contents rather than maintaining the blog files. This is what makes this workflow superior to a lot of other tools, because it brings the automation (that tools like WordPress offer) to a great text-editing environment like org-mode all within Emacs where I personally do a lot of other things (like coding, reading feeds, keeping notes, managing projects and ideas, ...).

*Here is my automated workflow (You can see a screenshot at the end of this post):*

I capture new ideas with org-capture (The next section, [[Using Org-Capture For Blog Ideas][Using Org Capture For Blog Ideas]], will cover how to set this up) under the *DRAFT* keyword and quickly add some rough ideas of what I want to add later. At this point, I rather not have it converted to markdown yet because maybe I end up deciding the topic is not right, and I don't even want to work on it until some other time. Later, when I find time to actually sit down and write up something, I go to my org-agenda list and find the blog post I want to work on and add some more contents and ideas and organize the post. I keep doing this over the next few days or weeks depending on availability until I get to a point when I feel that the content is indeed suitable for a blog post. At this point, I bump the heading to *POST* keyword, which automatically creates the markdown files. I am still not ready to publish this post because I probably don't have figures, and there are still minor details that need fixing. Therefore, in the markdown file, this is still marked as draft (determined by =:EXPORT_HUGO_DRAFT: true= in the properties' drawer), which allows me to see the post on my local web server (e.g. by running =hugo server -D= in the terminal) and decide how to polish and finalize it. Finally, when I'm done with editing the post and want to publish it on my website, I bump the heading up to *PUBLISH* and it automatically flags the post for publishing.

*Here is the code that enables the workflow:*

I have defined a function that changes =:EXPORT_HUGO_DRAFT:= property and also runs =(org-hugo-export-wim-to-md)= for me when I change the keyword.

#+begin_src emacs-lisp
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)
#+end_src

In the code above I am adding a function, =ad/org-change-draft-when-state-changes-to-publis= as a hook to run whenever a =TODO= keyword changes. This function runs =(org-hugo-export-wim-to-md)= to create the markdown files and also sets the =:EXPORT_HUGO_DRAFT:= to =true= or =false= depending on the status. Note that I have hooked the custom function to ='org-after-todo-state-change-hook= which runs on any =TODO= changes but since I am checking the todo state by =(org-get-todo-state)= this hook will only do something when the heading is one of *DRAFT*, *POST* or *PUBLISH*.

There are two more settings for my ideal setup to work as intended:
#+begin_src emacs-lisp
(setq org-log-done 'time
      org-log-into-drawer t)

(setq-default org-export-with-todo-keywords nil)
#+end_src

The code above makes sure that whenever a todo item is set as done (defined by putting the specific =TODO= keyword after ="|"= in the ='org-todo-keywords= list as mentioned [[*Using =org-todo= keywords][above]]). This is useful because ox-hugo uses this log time drawer to add the /"last updated timestamp"/ to markdown files.
Also, I make sure that =org-export-with-todo-keywords= is set to =nil=.

With this setup, I don't need to worry about anything but writing the content. As I change the =TODO= keyword, everything happens automatically in the background. In addition, I have everything set up with [[https://www.netlify.com/?utm_medium=paid_search&utm_source=google&utm_campaign=12755510784&utm_term=netlify][Netlify]] and [[https://github.com/][GitHub]], to automatically update my website when I push new changes to my git repository. As a result, the blogging workflow is as simple as capturing an idea and editing it in org-mode whenever I have time. Everything else happens magically in the background without me having to think or worry about it. Here is a screenshot showing how the new post gets added to the website when I change the keyword from *DRAFT* to *POST*.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/automatic_posting.gif]]

**** Using Org-Capture For Blog Ideas

The next useful step to take is to set up org-capture to quickly save new ideas. Often times blog ideas come to you randomly in the middle of something else, and you don't want to lose them. The org-mode ability to quickly fire up org-capture and write the idea down is therefore a crucial functionality that makes this workflow superior to a lot of other editors. To do this, I use the org-capture with a custom template. You can do this in different ways from minimal setup to more advanced ones, depending on your needs, as I show below.

***** Minimal Setup
You can add a simple template to your org-capture templates following the official instructions: [[https://orgmode.org/manual/Capture-templates.html][Capture templates (The Org Manual)]]. For example, the code below creates a new heading in the ="Blog.org"= file in default org directory under the Heading ="* Posts"=.

#+begin_src emacs-lisp
(add-to-list 'org-capture-templates
      `("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n"))
#+end_src

***** Better Set Up that Adds Ox-Hugo
The simple template above is sufficient for most basic workflows, but I personally like to use something a bit more advanced with automation and add capabilities for ox-hugo. Here is a better template which adds ox-hugo settings:

#+begin_src emacs-lisp
 (add-to-list 'org-capture-templates
      `(("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n:PROPERTIES:\n :EXPORT_HUGO_DRAFT: true\n :EXPORT_HUGO_SECTION_FRAG: \n :EXPORT_FILE_NAME: index\n :TITLE: \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary \n:END:\n\n#+begin_src yaml :front_matter_extra t\nauthors:\n  - admin\nprojects: []\nfeatured: false\ncommentable: true\nimage:\n  caption: 'caption'\n  focal_point: 'center'\n#+end_src\n"
         :empty-lines 1
         :prepend t
         :jump-to-captured t)
#+end_src

The code above adds the ox-hugo settings as =:PROPERTIES:= drawer to your entry and also adds some settings for convenience by =:prepend t= and =:jump-to-captured t=. It jumps to the file narrowed to the heading you just created in case you want to add some more text before finishing the capture process.

***** Advanced Setup with Ox-Hugo + Yasnippet
The template above covers provides all the essentials for an automated workflow, but it is still not the ideal version because but it is not dynamic enough, and some manual editing is still required. For example, I do not want to manually enter the file path for the markdown files. Therefore, in my own setup I take a different approach by using [[https://github.com/joaotavora/yasnippet][Yasnippet]] to do some auto-completion for me. Of course, this means that you need to install Yasnippet and set it up, which may not be what you want and hence the settings above, but in my case I am using Yasnippet for other things anyway, so I might as well use it here.

I define a capture function that calls org-capture but also enables yasnippet and inserts my snippet as a template. This is essentially a from with metadata fields that I can quickly jump to and fill by using the tab button.

#+begin_src emacs-lisp
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))
#+end_src
In the code above I use let-bindings to temporarily define a rather simple =org-capture-template= and call =(org-capture nil "d")= to get the org-capture buffer. Then I achieve the rest of what I need by loading and expanding a yasnippet snippet that contains the following:

#+begin_src emacs-lisp
# -*- mode: snippet -*-
# name: blog post template
# key:
# --
${1:title}
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: ${1:$(string-replace "\s" "_" yas-text)}
 :EXPORT_FILE_NAME: index
 :TITLE: $1
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle $2
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary $3
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [$4]
categories: [$5]
featured: false
commentable: true
image:
  caption: $6
  focal_point: 'center'
,#+end_src
$0
#+end_src

Note how the snippet takes the title and automatically generates the path for the markdown files using =:EXPORT_HUGO_SECTION_FRAG:=. In the screenshot below, you can see my capture process:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/org-capture.gif]]


**** Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda
An advantage of using org-todo keywords for items such as blog posts is that you can then quickly find all your items using [[https://orgmode.org/manual/Agenda-Views.html][Agenda Views]].

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))
#+end_src


Alternatively, you can use the awesome [[https://github.com/minad/consult][Consult Package]] by Alexander Miller and use =consult-org-agenda= to quickly search through your blog posts in the minibuffer. Here is some example code you can use after you install consult:

#+begin_src emacs-lisp
(consult-org-agenda "TODO={DRAFT\\|POST\\|PUBLISH}")
#+end_src

Personally, I have built some custom functions based on consult-agenda just for my blog posts that lists all my old posts with status and date, etc. and allows me to add new posts by entering a new title as well. I don't get into all that extra stuff in this post, but it is simply a custom setup for completing-read based on [[https://github.com/minad/consult][Consult]]. It allows me to see my previous posts or start new ones by entering a new title. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/consult-blog.gif]]

**** Bonus 2: Better looks for org-todo keywords
If you want to have some better looks for your org todo keywords, you can check the [[https://github.com/minad/org-modern][Org-Modern]] by Alexander Miller. If you want to have different faces or colors for different labels, you can set =org-todo-keyword-faces= per official instruction: [[https://orgmode.org/manual/Faces-for-TODO-keywords.html][Faces for TODO keywords (The Org Manual)]]. Here is an example:

#+begin_src emacs-lisp
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))
#+end_src


**** Bonus 3: Better Writing Environment inside Emacs
Don't forget to check out other packages that improve the actual content creation and writing texts in Emacs. [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]] is a good collection of articles. Different people have obviously different opinions and take different approaches. [[https://explog.in/notes/writingsetup.html][explog's wirting setup]] is probably a good starting point for any user. Jacob Moena's post on [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/][Creative Writing with Emacs]] provides a more comprehensive intro including some useful extra packages [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/#Extras][here]].

Personally, I think you have to try different packages and find the settings that is appealing to you and your use-case. But here are some suggestions based on my experience.
1. Toggle frame to full screen and hide all other Windows
2. Hide the =properties drawers= that are used for ox-hugo settings, by using =org-fold-hide-drawer-all=.
3. Use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][flyspell-mode]] for spell checking.

Put all of that in an interactive command, and can call it whenever you want to focus on writing:
#+begin_src emacs-lisp
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)
#+end_src
You can also add more settings to this function depending on your preferences. Here are some packages I suggest you try:
1. Consider [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] and [[https://gitlab.com/OlMon/consult-flyspell][consult-flyspell]] for better, more user-friendly interactive commands with flyspell.
2. Consider [[https://github.com/mhayashi1120/Emacs-langtool][Emacs-langtool]] for checking grammars etc.
3. Consider [[https://github.com/larstvei/Focus][Focus]] mode to get an effect similar to what WordPress calls spotlight.
4. Consider [[https://github.com/cyrus-and/zoom][zoom]] if you open multiple buffers and want the width to adjust dynamically
5. Try out other packages such as [[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] or [[https://github.com/sachac/artbollocks-mode][artbollocks-mode]].

Here is a screenshot of my setup with flyspell, olivetti and focus-mode.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/focus.gif]]


**** Bonus 4: Seeing Previews with =Hugo Server=
Obviously no good blog editor would be complete without a way to preview the post. If you use Hugo, you can see a preview by running =hugo server= in the terminal which fires up a local server (server default address is http://localhost:1313/). You can achieve the same by using a package like [[https://github.com/masasam/emacs-easy-hugo][emacs-easy-hugo]] from inside Emacs. However, that might be too overkill given that we can already do most of the functionality with org-mode and ox-hugo. Personally, I have defined a function that calls =hugo server= as a process within Emacs and a second function to kill the process.

#+begin_src emacs-lisp
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )
#+end_src

Note that the arguments =-buildDrafts= and =--navigateToChanged= are passed to =hugo server= to make sure you see your drafts and also automatically navigate to the most recent changes.
If you also have xwidget-webkit in your Emacs, then you may want to create another interactive command to open the page in a second buffer like below. If you don't have xwidget, you can use any other browsers for example by invoking =browse-url= to open the link in an external browser.

#+begin_src emacs-lisp
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src

This opens the local hugo server and navigates to the page for the post in the current buffer. Since we have =--navigateToChanged= turned on, as we edit the text we can see the changes right away. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/preview.gif]]


**** Putting everything together: Code and Screenshot

Here is a screenshot that shows the complete workflow:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/full_workflow.gif]]


and here is my preferred entire code (see the post for some alternatives if you don't have/want all the required extra packages below):

#+begin_src emacs-lisp

;; org-todo keywords
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))

;; org-todo faces
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))


;; function(s) to run on changing state
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)


(setq org-log-done 'time
      org-log-into-drawer t)

;; make sure org-todo keywords don't get exported
(setq-default org-export-with-todo-keywords nil)

;; capture function for blog posts
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))

;; custom org-agenda view
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))

;; enable extra packages for focusing on writing
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)

;; start the hugo server with Drafts and navigateToChanged
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

;; stop the hugo server process
(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )

;; get a preview of new drafts
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src


*** PUBLISH consult-gh: Working with GitHub inside Emacs in 2023
CLOSED: [2023-06-23 Fri 13:58]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: consult-gh:_Working_with_GitHub_inside_Emacs_in_2023_
:EXPORT_FILE_NAME: index
:TITLE: consult-gh: Working with GitHub inside Emacs in 2023
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle Introducing a new package for using GitHub interactively inside Emacs based on Consult and Embark
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary This post introduces my new Emacs package that uses the fabulous Consult and Embrak along with GitHub CLI tool to create an intuitive user-friendly interface for GitHub inside Emacs
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
tage:
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

**** Introduction
This section is essentially the philosophy behind this work addressing the question of "why do we need yet another package?" If this is not of interest to you, you can skip to the next section and look at the examples and screen shots, etc.

***** What is the need? Why make a new package?
I often find myself browsing GitHub for various reasons. Sometimes I go back to a package repo to read the documentation/manuals for installing or troubleshooting. Other times I browse the repositories by users whose works are of interest to me (for example [[https://github.com/purcell/emacs.d][Steve Purcell's Emacs Config]] or [[https://github.com/alphapapa][alphapapa (Adam Porter)]]'s packages for org-mode workflows). This is often done by doing a Google search finding the relevant GitHub Page and navigating from there to find the right content. It would have been great if I could do all of that from inside Emacs especially if I could then take some code from those repositories, paste it in an org-mode source block or a REPL and see how it works. But, as far as I know, no emacs package provides a user-friendly intuitive interface for such functionality. While there are multiple packages that interface with GitHub API like [[https://github.com/sigma/gh.el][gh.el]], [[https://github.com/magit/ghub][magit/ghub]], [[https://github.com/magit/forge][magit/forge]], [[https://github.com/sshaw/git-link][git-link]], [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] and ..., none of them provide the kind of functionality I am looking for.

Let's take a closer look at some of these to better understand where the gap is.

On one end of the spectrum, we have a package like [[https://github.com/sigma/gh.el][gh.el]] which seems to be an interesting option with a huge code base possibly covering a lot of low-level API calls to GitHub but there is not a single line of documentation on how to use it! The repo seems to be abandoned years ago, and the owner mentions on one of the issues that *"the whole thing was a gigantic experiment around the viability of eieio, and I'm pretty disappointed by the amount of suffering it generates, so I'm not sure I should push people to use it..."*. This is clearly not the right solution to use in 2023!

On the other end of the spectrum, we have packages like git-link and browse-at-remote that are relatively small (<1000 lines of code), but the functionality is very limited, getting the URL links for files and commits, etc. While these are very useful, especially because they cover sources other than GitHub too, they don't really provide a way to browse repositories or issues or search for new content.

Then there is of course magit packages, that are indeed incredibly useful for doing =git= commands from inside Emacs and it provides extended functionality in extra packages such as magit/forge to interface and work with issues and pull requests on multiple repository sources. However, this is geared toward repositories you actively work on and not so much toward browsing/finding new content. In other words, magit/forge does not provide simple interactive commands to find repositories or browse their content on demand without first cloning them or adding them to its database.

In addition, all of these packages were started several years ago, and since then there has been updates in Emacs as well as other tools like GitHub CLI that provide new opportunities for how we can interface with GitHub from inside Emacs. This is exactly what consult-gh is trying to do.

***** How does consult-gh do it?
The principle idea in consult-gh is that I only focus on providing what is missing and leave the rest to existing tools that provide the basic functionalities. For example, the [[https://github.com/cli/cli][GitHub CLI]] (=gh= commands in the terminal) is the right tool to use for interfacing with GitHub. After all it is the official CLI tool. By leaving jobs such as authentication and API calls to =gh=, we simplify the code and make it really easy to set up and use. In addition, we make the code more secure since we don't have to handle authentication tokens and at the same time we keep the code more maintainable because we don't have to worry about keeping up to date with the API, etc.
For comparison, if you set up magit/forge and go through all the steps you need to do to interface with GitHub, you'll see while leaving this job to a tool like =gh= might be a better approach for consult-gh (obviously in case of magit/forge that's not an option since it supports sources other than GitHub).

On the other hand, =completing-read= inside emacs provides a perfect tool for interfacing with users and running queries, etc. and in the recent years, there has been great improvements especially with a package like [[https://github.com/minad/consult][consult]] that wraps around completing read and provides easy to use features. Along with the rest of completion framework packages ([[https://github.com/minad/vertico][vertico]], [[https://github.com/oantolin/embark][embark]], [[https://github.com/oantolin/orderless][orderless]], ...), they provide a great toolset for functions that need input form users. Therefore by bringing =consult= and =gh= together, we can easily provide a concise, yet powerful tool that improves on the current alternatives for interacting with GitHub inside Emacs.

That said, let's keep in mind that the goal here is not to replace the existing functionalities with yet another tool but fill the gaps between the current tools. For example, consult-gh does not provide (at least not yet) a way to edit issues or pull requests because that functionality is available in magit/forge for not just GitHub but also other sources so I don't see any benefit in duplicating that in consult-gh (unless of course somebody convinces me otherwise!)

Another important factor to consider is that when it comes to interacting with repositories, there is a vast range of actions and commands, and different people would use it in different ways and that means we need a customizable tool that can mold to the users' desires. Naturally, it is difficult to come up with a one-size-fits-all solution and as a result a lot of tools that try to do this get bloated or fail to provide benefits compared to going back to the browser and therefore they don't stick. Emacs, however is a general tool with small packages that cover specific tasks very well and typical Emacs users often don't mind spending some time to tinker with configurations and build their own custom workflows. Therefore, inside Emacs we can build on available packages and tools that users will be using anyway and provide new functionalities with enough customizability that makes the overall experience better than "just the browser" or "gh" without creating a completely new tool that is bloated and hard to learn from scratch.

This is what I am trying to create with consult-gh. To do so, I am trying to balance between usability (a.k.a. having many commands for different use-cases and scenarios) and utility (being more efficient in practice for typical workflows than using a browser for example). To do so, I am providing *only a handful of interactive commands* to keep things simple, intuitive and easy to use, yet I am offering a range of customization to tweak the behavior so that the user can pick what is most useful in their day-to-day use. For example, the user can fetch a list of repositories matching a search term by running the command =consult-gh-search-repos=, but the action that happens after selecting a target repository is customizable. By default I provide a few useful functions for typical users, and allow advanced users to define their own custom commands if they wish to do so. If all the user wants is to open the url of a repository in the browser, that is provided by default. If they want to view the README in an emacs buffer, or see branches and browse the files they can do so by adding one line to their configuration. They can also choose to clone or fork the repository with one line of configuration. I also provide examples of [[https://github.com/oantolin/embark][Embark]] actions that can be used to do multiple commands on repositories and more. This should cover most of the typical use-cases, but if the user still needs something more complex beyond those actions, they can write their own custom commands and set them as default action to run when a target repository is selected. In other words, typical users can get the typical functionalities they use on a daily basis in a browser inside Emacs, hence better efficiency and customization. Advanced users, can come up with actions that are not possible in a browser and are hard to dynamically implement without a lot of scripting from scratch. Therefore, the balance between usability and utility should always be met no matter what the user is looking for.


**** How is Consult-GH Useful
If you read the Intro, you may be thinking, that is a lot of vague ideas that sound interesting on paper but in reality what can consult-gh do that is better than using a browser or just =gh= itself. "Can you convince me that that this is not just another shiny tool that looks nice but does not provide any meaningful new feature or functionality?". So in this section I am going to provide examples of use cases with context before we get down to codes and screen shots and how-to instructions in the next part. Again, if this is not of interest to you and you just want to see the examples in action and screenshots, jump ahead and see the next parts, otherwise keep reading.

There are a few GitHub accounts that I tend to keep going back to either because I am looking for some new tool or functionality I need or because I am trying to learn form their code, implementation and general approach. Before making consult-gh, my workflow for this was:

1. _Find the Source_: Do a Google search (for example to find "steve purcell emacs config") or open a bookmark (for example the GitHub repo of [[https://github.com/dakrone/eos][emacs operating system]])
2. _Find the relevant content_: For example by browsing through the files on a GitHub repo or looking at recent updates, commits, etc.
3. _Understand the Content_: This would usually require, copying code from the browser back to a REPL or IDE and interact with it and run examples to figure out what each part does and etc.
4. _Implement my own solution_: Finally, I have to decide if I would like to use the content I just learned in my own projects. For example, after looking at "Steve Purcell's Config" I need to decide whether I want to use some parts of it in my own config and if so how do I need to adjust and use it.


This is not very efficient because the tools I was using were not specifically designed for this. For example, Google is a great "general" search engine but if I want to go back to the same page on *eos* GitHub repo then, I probably have to bookmark that page. But as you may have experienced that would mean that I end up with many bookmarks and now I need another tool to search through my bookmarks to find the right page and sometimes I don't remember which bookmark was the right one and I perhaps have to go back and look at my notes if I took any and so on.
Moreover, when I finally find the source and content of interest, I am likely looking at some code in a browser, where syntax highlighting is often sub-optimal; no IDE or REPL is available to run and explore the code; help and documentation is not available to parse different pieces of the code; etc. Compare this with looking at code inside Emacs, where you can easily run snippets of codes to test and understand functionalities either by jumping to a REPL or by running code inside an org-mode source-block. In addition, at least in case of elisp code, help and documentation is always just a =C-h= key away! Such documentation is often proven extremely useful especially if you you also use a package like [[https://github.com/Wilfred/helpful][helpful]]. For non-elisp code, the chances are you can also find documentation, debugging and other tools inside Emacs by installing the right packages. Finally, when it comes to implementing my own solution, this would mean either copying code from the browser into a local file or forking/cloning the repository and then editing the code which means I would leave the browser and would go to an IDE tool such as Emacs.

Wouldn't it be great if I could do all of that inside Emacs to begin with? For example, let's say I am looking at [[https://github.com/purcell/emacs.d/][Steve Purcell's Emacs Config]] but instead of doing that in the browser, I can pull up the relevant repository and browse the files all from inside the emacs. If I see a piece of code I am interested in I can copy it to and org-mode source block and see what it does. If I need help and docs I can look things up in Emacs. I can do all of that without even cloning the repo. For another example, consider the scenario where I want to look at recent works from [[https://github.com/alphapapa][alphapapa]], see what new projects and repositories he has been working on. I can open his GitHub page in the browser and manually go over his more than 700 repos to find out, but wouldn't it be great if I could get a list of all his repos within Emacs, and search through them and interactively see README files? Then, if I see something of interest browse the files, or clone the repo and take things for a test drive all from within Emacs?

If your answer to those questions is yes or any of this rings a bell, then you will likely be interested in consult-gh and what I am about to show you in the next sections.


**** Features and Demo
In this section, I will show you examples of using consult-gh to interact with GitHub from within Emacs. The goal is to show the basic features and explain how things work and then provide examples of meaningful workflows that are more efficiently done with consult-gh than opening a browser or using other tools. Please note that I do not intend to go through all the details of installation, customization, configuration etc. here. Instead, I focus on showing the functionality. For instructions please refer to the documentation on the official [[https://github.com/armindarvish/consult-gh][consult-gh]] page.

***** Searching Users/Organization
In the previous section I mentioned an example of looking at [[https://github.com/alphapapa][alphapapa]]'s repositories. Let's see how that would work with consult-gh. As you will see in the screen shot below, you can run the interactive command =consult-gh-orgs=, enter a GitHub unsername and see a list of their repositories. One nice feature is that you can also enter multiple user names by using a crm-separator. and see all their repositories at the same time grouped by the user name.

Then depending on configuration (see the next section for details), you can do a number of different actions. For example, you can choose to see a preview (a.k.a. the README file inside an emacs buffer), or see the file contents inside Emacs. In the screenshot below I have turned preview on and set the action to show the file contents. I'll show you how to do that in the next section but for now here is a screen shot of how it looks.


#+attr_html: :width 320 :height 240 :controls t
#+begin_video
<source src="search-orgs.mp4" type="video/mp4">
#+end_video


In the screenshot above, I first searched for the user =minad= and looked at the preview (a.k.a. *README* file) of some repos. As you can see I can copy code or even evaluate source blocks from the preview buffer without even cloning or saving files! Then I searched for multiple accounts using comma as crm-separator (e.g. =systemcrafters, minad=). Then I searched for =alphapap=. As you can see, it takes some time to load more than 700 repositories from alphapa, but then you can easily narrow down by completion in minibuffer as I did for repos that start with =org-= . Most of the time, users won't have that many repos and therefore performance is not an issue but if it is, you can always set the max number of results for repositories (per account not total) by setting =consult-gh-repo-maxnum=.





****** Looking at a Default List of Repositories
You can also look at a default list of usernames to =consult-gh-default-orgs-list= and use =consult-gh-default-repos= to see their repositories. You can add any GitHub usernames to the list, but I use this to quickly open my own repos inside Emacs. Note that since we are using =gh= on the back-end, this can show private repositories of the account that is logged in as well.

***** Searching Repositories
More often than looking for specific users, I look up specific packages (e.g. org-roam, lsp-mode, ox-hugo, ...) to check manuals and documentation. Similar to what I mentioned above, before consult-gh, I would have used Google and a browser, but now I use most of it in consult-gh. Let's go through an example to see the functionalities.

Let's say I want to look at ox-hugo's documentation for [[https://www.armindarvish.com/en/post/building_an_efficient_blogging_workflow_in_emacs/][my blogging workflow]], or want to look at org-roam for my note-taking. In this case, I can use the interactive command =consult-gh-search-repos= and enter a search term.  When I search for =ox-hugo=, I get a number of hits and then I can choose the one I am looking for.

Now, let's go through some useful features and how to use them:

****** Previewing Repos
By default, previews are off because previewing a repo requires downloading the README file and that can be slow depending on your environment and network speed, etc. But in my config, I have turned consult-gh's previews on. I have also set the preview-mode to ='org-mode=. By default this is set to ='markdown= to preserve the contents since most README files are =.md= format but I trun it to org-mode because this makes it much easier for me to see source-blocks, etc. and evaluate them inside Emacs.

#+begin_src emacs-lisp
(consult-gh-show-preview t)
(consult-gh-preview-buffer-mode 'org-mode)
#+end_src

With this setting, when I move the cursor to ="kaushalmodi/ox-hugo"= in the minibuffer I see the README in org format in a preview buffer and I can read the contents. This is similar to visiting the homepage on GitHub except that I can also see codes with syntax highlighting, I can evaluate code in source blocks, and ... without leaving Emacs. Since loading previews can be slow, you may want to do this on demnad. You can do that by turning previews on and binding =consult-gh-preview-key= to a specific key. In the example below I turn the preview on and bind it to =M-o=.

#+begin_src emacs-lisp
(setq consult-gh-show-preview t)
(setq consult-gh-preview-key "M-o")
#+end_src


****** The Default Action and Some Options
Now if I hit enter to select a repo, then the default action function that is bound to the variable =consult-gh-repo-action= is run. By default, this is bound to the function =consult-gh--repo-browse-url-action= which opens the github page in the browser. This is again to optimize the performance, but if performance is not a concern, you can change the default function to something more useful for your workflow. Personally, I have changed it to =consult-gh--repo-browse-files-action= which allows me to browse the files inside Emacs. Here is my config
#+begin_src emacs-lisp
(consult-gh-repo-action #'consult-gh--repo-browse-files-action)
#+end_src

Note that this only fetches the file tree and does not download the files until you open the file (or preview it in a buffer). This way, you will only download the contents you want to see. Also, the files are stored in the system's default temporary directory so once you restart your computer, the space that is used to store the files is restored. Here is a screen shot where I search for the repo =minad/vertico= and then browse the file contents. In this case the preview is on and automatic.

There are other actions that are provided by default and you can use them as default action by setting =consult-gh-repo-action=. These actions include cloning or forking a repo, copying relevant links to kill-ring (e.g. homepage, https or ssh links for cloning, and and org-mode link). In addition I provide an example that copies a drop-in snippet with =straight.el= and =use-package= to kill ring. I can paste this snippet in my emacs config to install the package!

****** Embrak Integration
In addition to the default action, you can use alternative actions by using [[https://github.com/oantolin/embark][embark]]. The [[https://github.com/armindarvish/consult-gh/blob/main/consult-gh-embark.el][consult-gh-embark.el]] file provide some example of how to do this. Here is an example showing how to bounc =c= to embark action for cloning the repo:

#+begin_src emacs-lisp
(defun consult-gh-embark-clone-repo (cand)
  "Clone the repo at point."
  (funcall (consult-gh--repo-clone-action) (get-text-property 0 :repo cand)))

(defvar-keymap consult-gh-embark-actions-map
  :doc "Keymap for consult-gh-embark"
  :parent embark-general-map
  "c" #'consult-gh-embark-clone-repo
)

(add-to-list 'embark-keymap-alist '(consult-gh . consult-gh-embark-actions-map))

#+end_src

With the embark integration, you can have a quick way for doing alternative actions on items (repos, files, issues, etc.)

In the screen shot below you can see me cloning a repository by using embark. You can also define other custom functions and bound them to the embark keymap following the same patterns as those provided.


***** Finding Files
The next example is using =consult-gh-find-file=. This is a quicker way to see files if you already know the name of the repository. For example you can enter =minad/vertico= and browse the contents. Similarly to what was mentioned for repos, you can also run different functions on files. By default consult-gh opens the file url on github when you select it, but you can configure it to open the file in emacs. This makes an API call and downloads the file contents, so it may be slow for large files but in my tests so far the speed has been great even for some large files.

Here is a configuration to set consult-gh to open files inside emacs.

#+begin_src emacs-lisp
(consult-gh-file-action #'consult-gh--files-view-action)
#+end_src
When you set the function to browsing files, consult-gh asks you to select a branch by default but you can change the setting (see documentation on [[https://github.com/armindarvish/consult-gh#consult-gh-default-branch-to-load][consult-gh-default-branch-to-load]] variable).

As mentioned above, previewing a file will also fetch the contents and therefore you may want to limit previews to on-demand only by setting a preview key.

***** Searching Issues
In addition to repos and files, you can also browse issues with =consult-gh-search-issues=. You first asked enter a search term for issues (and you cna pass an empty string if you want to see all issues of specific repos), then you are asked to enter name of repos (in =user/repo= format for example =armindarvish/consult-gh=). You can pass an empty string to this and consult-gh will search for issues in any repo. You can set the =consult-gh--issues-state-to-show= to =open=, =closed= or =all= to change the issues that are shown. Similar to what was mentioned for repos, and files you can then run different actions on issues. By default the action is set to =consult-gh--issue-browse-url-action= that opens the url in a browser but you can also change that to =consult-gh--issue-view-action= to see the issue inside an emacs buffer.

Here is a screen shot

***** Taking it to the Next Level
The examples above show uses that are common for many users on a daily basis. But there are a lot more you can potentially do by using consult-gh.

****** Working with Multiple Repos All at Once
Moreover the integration with embark allows some more complex functionalities such as working on multiple repos or files. Let's say I want to look at all the repos by alphapapa and clone a few of them that are related to org-mode. Now since alphapapa has over 700 repositories in his account, I first need to increase the maximum number of results I normally get:

#+begin_src emacs-lisp
(setq consult-gh--repo-maxnum 1000)
#+end_src

Then I can run =consult-gh-orgs= and look for =alphapapa=. This takes some time to load all the repositories but this is way faster than browsing through GitHub to find the repositories manually. Then in the result I search for ="org-"= and run embark select (bound to =SPC= by default) and once I select everything, I run embark act on all (bound to =A=) plus the consult-gh-embark-repo-clone (bound to =c= in my setup). By default, consult-gh wil go through every repository and confirms the repo I want to clone and the path, etc. But if you happen to do this often, you can configure consult-gh to always clone the repositories in a folder where you keep your repositories (e.g. "~/code" or "~/projects") and then set =consult-gh-confirm-before-clone= to nil:

#+begin_src emacs-lisp
(setq consult-gh-default-clone-directory "~/code")
(setq consult-gh-confirm-before-clone nil)
#+end_src

With this setting consult-gh just clones the repositories with the repo's default name under ="~/code"= folder. Browsing GitHub in the browser or using =gh= in the command line will never be this fast!

****** Actions on Multiple Files (e.g. Comparing Files)
In addition to viewing files, you can also select multiple files by using =embark-select= and run a function on multiple files, for example if you want to download a selection of files without cloning the whole repository. In addition you can use a crm-separator and search for multiple repos (or the same repo multiple times and select different branches) and then compare files (for example with =ediff= or [[https://github.com/justbur/emacs-vdiff][emacs-vdiff]]). This can be done without cloning the repo or even permanently saving the file on your local machine (by default consult-gh loads previews by downloading files in system temp directory).

The screenshot below shows some interesting use cases.
- Previewing files in a repo
- Running vdiff on files in different branches of the same repo.
- Comparing files across repositories (for example to compare LICENSEs or compare between different forks, ...)


Similarly you can use embark-select and embark-act-all to run commands on multiple files possibly even from different repos or from different branches of the same repo.

One interesting example is to run a diff on the same file in two different branches of the same repo without cloning the repo and runing git diff. In the screen shot below, I search for the repo =minad/consult= then I select it twice (separated by my default crm-separator in this case =,=) and select two different branches, then I see the file trees for the two branches. I search for a file (e.g. "README")that narrow downs the items in both branches and I select them and I open previews for both branches by hiting "M-o". Now I have both files in an open buffer. I quit consult-gh and run vdiff-buffer and select the two buffers visiting those files. Of course you can achieve this by cloning the repo and running git diff but this is much faster especially if you don't want to clone the entire repo.



For example, let's say you want to clone a bunch of different repos. Instead of navigating to GitHub pages and getting the links and running "git clone" commands, you can just search multiple accounts with =consult-gh-orgs= or multiple repos with =consult-gh-search-repos= using =consult-gh-crm-separator= and then clone all of them at once. Note that for this scenario you may want to turn the confirmation off and set a default path for cloning as shown in the code below.

#+begin_src emacs-lisp
(setq consult-gh-default-clone-directory "~/code")
(setq consult-gh-confirm-before-clone nil)
#+end_src

****** Extending Functionality with Custom Functions
Advanced users who don't mind writing a few lines of code to build custom workflows can further expand on the built-in functionalities by mixing different functions and actions. For example, let's say you want to add the same file (e.g. a new LICENSE) to multiple repos. You can create a custom function that clones the repo, adds a file, commits the changes and pushes to the remote. With the right packages already installed, this will only be a few line of codes in elisp. Then you make an embark action similar to examples provided in [[https://github.com/armindarvish/consult-gh/blob/main/consult-gh-embark.el][consult-gh-embark.el]]. Now you can search GitHub, select any repo (or multiple ones) and run this command on them! Isn't that neat?

In fact let me just try to write the code for that  specific example with the simplest implementation right now:

#+begin_src emacs-lisp
(defun consult-gh-clone-and-add-file (repo file &optional clonedir)
  (let* ((clonedir (or "~/tmp/code" clonedir))
        (reponame (car (last (split-string repo "\/"))))
        (filename (file-name-nondirectory file))
        (newname (expand-file-name filename (expand-file-name reponame clonedir)))
        )
  (consult-gh--repo-clone repo clonedir reponame)
  (copy-file file newname t)
  (expand-file-name reponame clonedir)
 ))

(defun consult-gh-embark-clone-and-add-file (cand)
  "Clone the repo at point."
  (let* ((repo (get-text-property 0 :repo cand))
        (file (read-file-name "Select File: "))
        (repodir (consult-gh-clone-and-add-file repo file))
        (default-directory repodir)
        )
    (shell-command "git add .")
    (shell-command (concat "git commit -m \"" file " added\""))
    (shell-command "git push origin main"
  )))

(defvar-keymap consult-gh-embark-actions-map
  :doc "Keymap for consult-gh-embark"
  :parent embark-general-map
  "v" #'consult-gh-embark-clone-and-add-file
)

(add-to-list 'embark-keymap-alist '(consult-gh . consult-gh-embark-actions-map))
#+end_src


That is 30 lines of code (and could possibly be optimized since I just wrote it in 5 minutes) that allows me to do something quite complex. Of course in Emacs, there might be other better ways to achieve this specific task, but this shows you how you can quickly build custom workflows with consult-gh.







browse contents (see different branches and the files) and directly open them inside an emacs buffer or if you wish you can clone or fork the repo. You caneither open the repository urls in the browser or open

inside emacs without going to the browser. You can of course keep a local copy by cloning the repository and then pulling the latest updates every time you want to browse it, but that would waste some space on your local drive and often times you might not be interested in the whole repo anyway. In other cases, you may want to see people's new work, e.g. new repositories, and without knowing the name and links of the repo, you still have to go to the browser to find those. consult-gh provides an easy way to see the repositories from people you want to follow and quickly browse single files or clone entire repositories.

As seen in the screenshot below, the command =consult-gh-orgs= allows you to search GitHub users and see their repositories. Importantly, you can also search for multiple users at the same time. By default your search history is saved and accounts but only the search terms that produce any results will be stored in =consult-gh--known-orgs-list=. As  a result you will have quick access to user accounts you have looked up before, and if you want to preserve that between emacs sessions, you can turn =savehist-mode= on and add =consult-gh--known-orgs-list= to =savehist-additional-variables=:

#+begin_src emacs-lisp
(add-to-list 'savehist-additional-variables 'consult-gh--known-orgs-list)
#+end_src




**** Future Ideas
There are a few other ideas that i have in mind and I may implement them in the future as time allows and would welcome anybody that would like to contribute to these or potentially other interesting ideas:

1. I would like to provide a simple interface for multiple profiles. This should be easily achievable using enviroment variable like GH-CONFIG-DIR, but I still need to decide what would be the right way of implementing it. Should be a global variable in consult-gh or shall we dfine local pe buffer variables, etc.

2. I think we can improve the current interface of =consult-gh-find-file= to make it behave more like find-file in emacs where folders are expanded dynamically as the user makes step-by-step selections to navigate the folders. This is however not the best approach for looking at files in multiple repos, so I may have to keep the current aproach for multiple repos, but I'd love to hear suggestions on that. I briefly talked to minad (the owner of the consult repo) and it seems that there are good ways of implementing a dynamic completion table for file-names with consult. But so far between my limited elisp skills and lack of good in-detail documentation on emacs completion tables, I have only had partial success with it and there are still many quirks to deal with. So this may take some time to implement.

3. The =gh= command in the terminal provides additional arguments to further filter search results for example to filter issues by date or tags, etc. This is not yet implemented in consult-gh. I think it can be added by some minimal effort if I enable extra arguments in some of the calls to gh (that I can of course turn into a rabbit hole that takes weeks but I think it'd be doable at the end anyway). However, I am not yet convinced that this will add much value. I think having too many options can negatively affect the user-friendliness and efficiency of the package. There is always going to be some use-cases where jumping to the browser would be a better option after all. I'd be interested to hear counter arguments if any though especially if there are ideas for clean and simple interface that allows using such options with an intuitive interface.
*** PUBLISH Use Emacs as a ChatGPT App from Anywhere on Your System
CLOSED: [2023-06-22 Thu 18:44]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Use_Emacs_as_a_chatgpt_client
:EXPORT_FILE_NAME: index
:TITLE: Use Emacs as a ChatGPT client from anywhere on your system
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I will show you how you can quickly make a chatgpt/bing client inside emacs that you can call from anywhere on your system (e.g. spotlight search on macOS)
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
categories: [software, ChatGPT, Emacs]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

In this post, I will show you how you can easily create a ChatGPT app on your system using the existing packages for ChatGPT in Emacs and call it from anywhere on your system. If you are on a system where you don't have an app (like macOS or Linux) and don't like to using the browser, this might be a good way of using ChatGPT plus the fact that you can integrate this with all sorts of other things you can do inside Emacs.

**** ChatGPT Clients in Emacs
There are a number of packages for ChatGPT client inside Emacs and I have tested a few of them so far. In my opinion, Karthik Chikmagalur's [[https://github.com/karthink/gptel][gptel]] is the best one both in terms of functionality and ease-of-use and also in terms of implementation and staying true to Emacs way of doing things. Therefore, if you are not interested in testing things out, just go ahead and use gptel and you can skip the rest of this section. There is a good (but long) live stream by David Wilson on System Crafters channel if you want to see gptel in action: [[https://www.youtube.com/watch?v=JImYEdqVQR8][Crafting the Future: AI Assistants in Emacs - System Crafters Live! - YouTube]].

If you want to know more about different packages, here are some notes:

***** GPTel
As I said above [[https://github.com/karthink/gptel][gptel]] is the best client I have tested so far. It is simple, does not have weird dependencies or authentication process, and provides an emacs-like experience (e.g. works in any buffer, does not create a million different buffers, ...) It is fast and async, and installation is straightforward since it is on MELPA. The code itself is also clean and easy to read, if you want to tinker with it and create your own custom functions or macros.

***** emacs-aichat
[[https://github.com/xhcoding/emacs-aichat][emacs-aichat]] works as expected but is not as clean in implementation as gptel. It does offer the option to use Microsoft's BingAI instead of ChatGPT but otherwise is not as good as gptel. It uses [[https://github.com/ahyatt/emacs-websocket][emacs-websocket]] and [[https://github.com/chuntaro/emacs-async-await][emacs-async-await]] which adds extra dependencies and the way the code is implemented there are many layers of functions and macros calling each other even though at the end it is using =url-asynchronous= to make calls to APIs. There are duplicates of similar functionalities for BingAI v.s. OpenAI's ChatGPT and different ways to do authentication or setup for them. As a result the code is complicated to read and debugging (which is expected with experimental packages like this) or building on top of it is not as easy. That said the author is quite responsive and has been improving things frequently.

***** openai and chatgpt
You can take a look at [[https://github.com/emacs-openai/openai][openai]] and [[https://github.com/emacs-openai/chatgpt][chatgpt]], and other related packages by Jen-Chieh Shen.  [[https://github.com/emacs-openai/openai][openai]] provides low-level calls to OpenAI API and [[https://github.com/emacs-openai/chatgpt][chatgpt]] builds on top of that for using the ChatGPT. The author has also other packages for other OpenAI services. I think the implementation is very neat and everything is done in a modular way, so this is a good reference if you want to learn and perhaps even build your own ChatGPT client inside Emacs. That said, I personally don't like the interface of the [[https://github.com/emacs-openai/chatgpt][chatgpt]] package. It opens up new buffers for inserting queries and does not play well with evil-mode. The gimmicky UI elements like spinners and so on seem unnecessary. They do not provide extra functionalities and are not pretty enough to add value to the user experience either. I think if you spend enough time configuring the package and trimming things up, this can be a decent ChatGPT client, perhaps with more features than some other packages I've tried, but I prefer a simpler interface that are faster and more user-friendly.

***** org-ai
[[https://github.com/rksm/org-ai][org-ai]] takes a different approach to interacting with ChatGPT (and in this case also DALL-E) and that is by using source blocks inside Emacs org-mode. I tried it shortly and decided that I personally prefer other approaches. The reason is inserting ChatGPT responses inside an org source block means that the code blocks in ChatGPT responses are now nested inside another code block which is not useful. I probably would have preferred if the response was returned as result (similar to [[https://github.com/suonlight/ob-chatgpt][ob-chatgpt]] below). Also, I don't think a conversation with AI using natural language really belongs in a source block (which is really designed for coding). But that's just my personal opinion. I can see how some people may prefer this over other approaches. You can try it yourself and see if it fits your use case.

***** ChatGPT.el and ob-chatgpt
Josh Cho's [[https://github.com/joshcho/ChatGPT.el][ChatGPT.el]] is perhaps the worst approach among the ones I have tried. The implementation is unnecessarily complicated. It uses python and [[https://github.com/mmabrouk/chatgpt-wrapper][chatgpt-wrapper]] under the hood to interface with OpenAI API and all it really does is to run a =shell-command= that does =pip install chatgpt-wrapper=. The authentication process uses an external browser and is very clunky and often requires re-authentication because it is using chatgpt-wrapper under the hood which runs python scripts. In addition, there is Minh Nguyen-Hue's [[https://github.com/suonlight/ob-chatgpt][ob-chatgpt]] which is built on ChatGPT.el but uses org-babel source blocks instead. Since it is using ChatGPT.el, it has all the issues of ChatGPT.el as well.

**** Configuring GPTel
Install [[https://github.com/karthink/gptel][gptel]] following the official documents, then all you have to do is to set up your API key by setting =gptel-api-key= and you are good to go. You can call the interactive command gptel by =M-x gptel= and you will jump to a ChatGPT buffer where you can type your prompts and submit them by =C-c RET=. If you have access to *GPT 4.0*, you can set that up by setting =gptel-model=. You can also use =org-mode= instead of =markdown-mode= by setting =gptel-default-mode= but *be aware that this converts the response to org-mode by simple regex replacement and often creates mistakes and bugs*. For example, I have noticed random *=* signs in elisp codes because the conversion replaces *`* with *=* to convert inline code from markdown to org-mode, and sometimes it makes a mistake and does that inside a code block.

Here is an example code for installing gptel using =use-package=:

#+begin_src emacs-lisp
(use-package gptel
   :config
   (setq gptel-api-key (auth-source-pick-first-password :host "openai.com"))
   (setq gptel-default-mode 'org-mode)
   (setq gptel-model "gpt-3.5-turbo")
   )
#+end_src

Note that I am using auth-source to store my OpenAI's API key so I don't need to put it in my config. Refer to [[https://github.com/karthink/gptel#usage][gptel documents]] for more info on authentication.

**** Creating a Custom Function to Call gptel
Now that we have gptel installed and running, you can go ahead and create an interactive command to call gptel. We can then use this command to call =gptel= from outside Emacs with emacsclient. Here is a sample function that creates a new frame and runs gptel.

#+begin_src emacs-lisp
(defun ad/ai-from-anywhere ()
(interactive)
(let* ((screen-width (display-pixel-width))
       (screen-height (display-pixel-height))
       (frame-width (/ screen-width 3))
       (frame-height screen-height)
       (frame-left (- screen-width frame-width))
       (frame-top 0)
       (chat-frame (make-frame `((window-system . ns)  ;;change this if you are not on macOS. For example you can use "x" instead of "ns" for x systems. Refer to make-frame documentation for more details
                            (top . ,frame-top)
                            (left . ,frame-left)
                            (width . (text-pixels . ,frame-width))
                            (heigth . (text-pixels . ,frame-height))
                            (minibuffer . t)
                            ))))
  (select-frame chat-frame)
  )
  (add-hook 'gptel-post-response-hook (lambda () (goto-char (point-max))))
  (gptel "My:AI Chat" gptel-api-key nil)
  (switch-to-buffer "My:AI Chat")
  (delete-other-windows)
)
#+end_src
Note how I set the window-system to =ns= (this is for macOS or Linux) and set the frame size and position in pixels by changing =width=, =height=, =top=, =left=, etc. when calling =make-frame=. Refer to Emacs help on =make-frame= or the manual on [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters][Frame Parameters]].

**** Setup your Emacs Server
From inside Emacs, you CNA simply run =server-start= to start an Emacs server, and then you can run =emacsclient= from terminal. If you want to run the server as *daemon* in the background, look at [[https://www.emacswiki.org/emacs/EmacsAsDaemon][EmacsWiki: Emacs As Daemon]]. If you are on macOS, this [[https://briansunter.com/blog/emacs-daemon-macos][link]] can provide some more details in addition to EmacsWiki article.

**** Create a script to call Emacsclient
Once you have the server set up and running, you can call emacsclient and run your interactive command to create a new frame and start gptel.

***** macOS
 On macOS, you can do this by writing an apple script and call it from spotlight search similar to this article for org-capture: [[https://macowners.club/posts/org-capture-from-everywhere-macos/][Org capture from everywhere in macOS | macOS & (open-source) Software]]. Simply, open *Script Editor* and make a new *Application* with content similar to the following code. Make sure you adjust the path to your emacsclient and also the name of the interactive command you are calling. Note how I use =select-frame-set-input-focus= to make sure the window is focused.

 #+begin_src apples
on run
    try
        do shell script "/opt/homebrew/bin/emacsclient -e \"(progn (select-frame-set-input-focus (selected-frame)) (ad/ai-from-anywhere))\"> /dev/null 2>&1 &"
    if application "Emacs" is running then
        tell application "Emacs" to activate
    end if
    end try
end run
 #+end_src

Save the file as *Application* in your default applications folder and name it something easy to remember like =myai=.

Then call the spotlight search (bound to =⌘ SPC= by default) and search for your new application (e.g. =myai=). When you run it, it should create a new Emacs frame, and you can start chatting with GPT right away.

***** KDE Plasma
You can do something similar in KDE Plasma. You can create a custom shell script with the following content:
#+begin_src shell
#!/bin/bash
emacsclient -e \"(progn (select-frame-set-input-focus (selected-frame)) (ad/ai-from-anywhere))\"
#+end_src

Save the script in a convenient location such as =~/.local/bin/myai= and make sure to make it executable by using =chmod u+x ~/.local/bin/myai= . Then call the =KDERunner= (bound to =Alt SPC= by default) and search for your shell script.

***** Other Systems
I have not tried this on other systems, but you can similarly make shell scripts to call emacsclient and run similar searches on most systems (windows button on Windows, unity search on, etc.) and you will have a ChatGPT app.


**** Screenshot
That's it. Now go get a cup of coffee and start a conversation with our future overlords. Make sure you are nice to them!

Here is a screen shot of my ChatGPT app on macOS:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Use_Emacs_as_a_chatgpt_client/Screenshot.gif]]







*** DRAFT Why scientists need a website?            :@software:@scientists:web:
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: why_scientists_need_a_web
 :EXPORT_FILE_NAME: index
 :TITLE: Why Scientists Need a Website
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'caption'
  focal_point: 'center'
#+end_src


* fa
:PROPERTIES:
:EXPORT_LANGUAGE: Farsi
:EXPORT_HUGO_SECTION_FRAG: fa
:END:

** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH شروعی ساده
CLOSED: [2023-02-09 Thu 12:01]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: شروعی ساده
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle در مورد وبسایت و وبلاگ 
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary «معرفی وبسایت»
:END:
#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'This is an art made by midjourney AI and Armin'
  focal_point: 'center'
categories: ["نرم افزار", "طراحی وب", "درباره"]
#+end_src

**** *در چند جمله*
من اخیراً تصمیم گرفتم وبسایت قدیمی خود را بازطراحی و احیا کنم و در ادامه تصمیم گرفتم که از این پس نوشته های پراکنده خود را به صورت پست های وبلاگی در همین وبسایت منتشر کنم. به احتمال زیاد موضوعات پستها طیف متنوعی خواهند داشت اما سعی میکنم بیشتر به حوزه تخصص خودم به ویژه تکنولوژی سلامت بپردازم. همچنین دوست دارم تجربیات خودم را در استفاده از ابزارهای نرم افزاری به اشتراک بگذارم، به عنوان مثال پستهایی مثل "چگونه از emacs و ox-hugo برای نوشتن وبلاگ استفاده کنیم" یا "استفاده از NLP و python برای استخراج اطلاعات فنی از گوگل پتنت" و ...

****  *چطور همه چی شروع شد*

من برای اولین بار در سال ۱۳۹۱ شروع به طراحی این وب سایت کردم. در آن زمان، من در دانشگاه درکسل در آمریکا دانشجوی دکترا بودم و در حوزه نانوحفره های مصنوعی به عنوان حسگرهای زیستی مشغول به مطالعه و تحقیق. من می‌خواستم وبسایتی بسازم تا مجموعه تحقیقات و علایقم را به نمایش بگذارم و در این فرآیند درباره طراحی وب، «HTML» و «CSS» نیز اطلاعات بیشتری کسب کنم. وقتی متوجه شدم که می‌توانم وبسایت خود را در فضای صفحه وب شخصی دانشگاه درکسل میزبانی کنم، این پروژه به سادگی شروع شد. پس از تحقیقات اولیه، فکر کردم خوب است که وب سایت را بدون اسکریپت (یعنی فقط با «HTML» و «CSS») طراحی کنم و در عین حال فقط از کار خودم استفاده کنم به این معنی که همه چیز از عناصر طراحی (لوگوها، دکمه ها و غیره) تا بلوک های «HTML» ساخته خودم باشد و نه کار شخص دیگری [fn:کارخودم]! اولین پیش نویس طرح در چند روز آماده شد، اما طراحی و کدنویسی کمی طول کشید، به خصوص به این دلیل که باید CSS را از ابتدا یاد می گرفتم و اجرای طرح اولیه ساده نبود، چرا که از شش ضلعی و حاشیه های مورب استفاده می کرد (برای مثال این [[https://archive.armindarvish.com/research.html][لینک]] ببینید) ، که به راحتی قابل اجرا نبود به خصوص اینکه فقط از «HTML» و «CSS» استفاده می کردم. اولین نسخه در سال ۱۳۹۲ منتشر شد و کمی پس از آن نسخه اولیه فارسی  را به وبسایت اضافه کردم. اما در همین حین، من درگیر تحقیقات دکترای خود شدم و به روز نگه داشتن وبسایت با دو زبان بیشتر از آنچه پیش بینی می کردم وقت میبرد، بنابراین پیشرفت کار کند شد. سپس در اواسط سال ۱۳۹۵ فارغ التحصیل شدم و به کالیفرنیای شمالی نقل مکان کردم تا برای یک شرکت کوچک و نوبنیان کار کنم،  جایی که روزانه به طور متوسط ​​بین ۱۲ تا ۱۴ ساعت وقت می‌گذاشتم [fn:کارزیاد].بنابراین دیگر فرصتی برای کار بر روی پروژه های شخصی از جمله این وب سایت نبود. این نسخه از وبسایت را میتوانید در این [[https://archive.armindarvish.com/index_fa.html][لینک آرشیو]] ببینید.

**** *شروعی تازه*

این پروژه پس از آن برای چند سال بدون به‌روزرسانی رها شد تا اینکه من نهایتاً در سال ۱۳۹۸، تصمیم گرفتم شرکتهای نوپا و ساعات کار طولانی آنها را ترک کنم و به یک شرکت بزرگتر و پایدارتر با ساعات کاری انسانی‌تری بپیوندم. در نتیجه یک بار دیگر این فرصت به وجود آمد که به کار بر روی پروژه های شخصی از جمله این وب سایت بپردازم.  یک بار دیگر فرصتی برای بررسی پروژه‌های شخصی پیدا کردم و تصمیم گرفتم این وبسایت را احیا کنم. ایده احیای وبسایت با این واقعیت که دانشگاه درکسل تصمیم گرفت سروری را که میزبان وبسایت اصلی من بود خاموش کند تقویت شد.در ادامه تصمیم گرفتم که از یک زنجیره ابزار جدید استفاده کنم، زیرا نگهداری وب سایت قدیمی با «HTML» و «CSS» آسان نبود، به علاوه این فرصت خوبی بود برای اینکه دوباره ابزار و مهارت های جدیدی را یاد بگیرم. بعد از کمی تحقیق، تصمیم گرفتم که از[[https://gohugo.io/][«Hugo»]]، به همراه [[https://www.github.com/][«GitHub»]] و [[https://www.netlify.com/][«Netlify»]] استفاده کنم، و بعد از دیدن نمونه های مشابه (مثل این [[https://www.aidanscannell.com/][صفحه]]) و توصیه ها و راهنماهای آنلاین (مثل [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][اینجا]])، تصمیم گرفتم از طرح [[https://academic-demo.netlify.app/][«Academic»]]  از [[https://wowchemy.com/][«wowchemy»]] استفاده کنم و نتیجه همین شد که میبینید.

**** *پس از این*

با استفاده از زنجیره ابزار جدید، به روز رسانی این وب سایت بسیار آسانتر شد. در واقع به روزرسانی آنقدر آسان شد که تصمیم گرفتم می توانم یک وبلاگ هم به این پروژه اضافه کنم. پیش اط این من یادداشت‌های پراکنده‌ای را اینجا و آنجا در پلتفرم‌های رسانه‌های اجتماعی مختلف منتشر کرده بودم، اما اکنون می‌خواهم همه چیز را اینجا در وب‌سایت خودم نگه دارم. هدف جدید من در این پروژه این است که عادت کنم به نوشتن پست های کوتاه در مورد موضوعات جالب و ساخت مجموعه ای از افکار، ایده ها، یادداشتها و دستورالعملهایی که به مرور جمع آوری میکنم. احتمالاً در مورد موضوعات مختلفی که به آنها علاقه دارم مانند بیوتکنولوژی، نانوحسگرها و تکنولوژی سلامت خواهم نوشت. همچنین دوست دارم که تجربه خودم از استفاده از  ابزارهای نرم افزاری مانند استفاده از «emacs» مثلاً برای ایجاد همین پست و یا نحوه استفاده از «midjourney» برای ایجاد پس زمینه های جالب برای وب سایت خود، یا استفاده از «python» و «NLP» برای استخراج اطلاعات فنی از پتنت های گوگل و ... بنویسم.

در حالی که این یک وبلاگ چند زبانه خواهد بود، همه پست ها به همه زبان ها در دسترس نخواهند بود و نوشته های فارسی لزوماً ترجمه نوشته های انگلیسی نیست. افکار، تجربیات و شاید حتی شخصیت من در محیط هایی با زبان های مختلف یکسان نیست و بنابراین، مطالب پست های من نیز انعکاس این تجربیات خواهند بود.



* Footnotes
[fn:mywork] The only exception was the map widget

[fn:کارخودم] البته به جز بعضی المانهای خاص مثل نقشه!

[fn:کارزیاد]توصیه میکنم که این حد از کار را به هیچ عنوان تجربه نکنید چون برای جسم و مغز و روح و روانتون مضره!

[fn:Netlify]Note to self: write another post about choice of tools and how to build a website with hugo, github and netlify!

[fn:longwork] I Don't suggest trying that yourself. It's not good for your physical or mental health!


#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'headline
          (lambda (hl)
            (when (string-equal (org-element-property :raw-value hl) "Humble Beginnings")
              (org-element-map (org-element-contents hl) 'paragraph
              (lambda (paragraph)
                (insert paragraph)
              )))))



#+end_src

* COMMENT Local Variables                                             :ARCHIVE:

# Local Variables:
# eval: (org-hugo-auto-export-mode t)
# eval: (my:blog-minor-mode +1)
# End:
