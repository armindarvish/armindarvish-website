#+OPTIONS: author: nil
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_lastMod: t
#+hugo_front_matter_format: yaml

* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH Humble Beginnings                  :@software:@webdesign:@about:
CLOSED: [2023-02-09 Thu 11:49]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: Humble Beginnings
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle About this Website and Blog
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary The totally necessary "about this blog..." post to introduce this website and blog
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption: 'This art was generated by AI and /\\r|\\\\/|i|\\\\|'
  focal_point: 'center'
#+end_src
**** *TLDR*
I recently decided to redesign and revive my old website and in the process, I decided that I would like to make a habit of writing blog posts here on my own websites. I'll likely be covering a range of topics mostly around research especially in healthcare technology. I'll also share my experience with software tools and workflows for example "How I am using emacs and ox-hugo to write this post" or "using NLP and python to extract interesting information from patents" and ...

**** *How it all started*
I first started working on this website back in 2013. At the time, I was a PhD student at Drexel University working on solid-state nanopores biosensors. I wanted to make a website to showcase my research portfolio and interests and in the process learn more about web design, HTML and CSS as well. I figured I could host it on Drexel's personal web pages and that's how this project simply started. After some initial research, I thought it would be nice to make the website script-free (only HTML and CSS) and only use my own work meaning that everything from design elements (logos, buttons, etc.) to HTML blocks had to be my own creation and not someone else's work[fn:mywork]! The first draft of the design was ready in a few days, but design and coding took some time especially because I had to learn CSS from scratch and my design was tricky to implement because I had hexagons and diagonal borders (see this [[https://archive.armindarvish.com/research.html][link]] for example) which was not straightforward, especially with HTML and CSS only. The first version was published later in 2014 and soon after I added a skeleton for my native-speaking language, Farsi. However, in the meanwhile I got very busy with my PhD research and keeping everything up to date with two languages was simply more work than I anticipated, so the progress slowed down. I then graduated in the middle of 2016 and moved to Northern California to work for a small start-up, where I found myself spending an average of 12–14 hours a day at work[fn:longwork]. That left me with no time to work on any personal projects including this website. You can see the old design in [[https://archive.armindarvish.com/][archive]].

**** *A New Beginning*
The project was abandoned for years with no updates while I was working for start-up companies in Silicon Valley. Then in 2019, I decided to leave the start-up scene and its ridiculously long working hours for greener pastures in a bigger, more stable company with more humane hours, and once again I found some time to consider personal projects and decided to bring this website back alive. The idea was further reinforced by the fact that the hosting server I was using was shut down by Drexel University. I decided it would be better to use a whole new set of tool chain, since the old website with HTML and CSS was not easy to maintain, plus the fact that this was again a good opportunity to learn new tools and skills. After some brief research I decided that I want to use [[https://gohugo.io/][Hugo]] combined with [[https://www.github.com/][GitHub]] and [[https://www.netlify.com/][Netlify]][fn:Netlify], and after some more browsing, looking at other people's examples (e.g. [[https://www.aidanscannell.com/][Aidan Scannell's Page]]), and reading online instructions (like [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][this one]]), I decided to give [[https://academic-demo.netlify.app/]["Academic Theme"]] from [[https://wowchemy.com/][wowchemy]] a try and the result is what you are looking at.

**** *Going Forward*
CLOSED: [2023-02-09 Thu 11:47]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:END:
Using Hugo and Netlify, made it really easy to update my website in more than one language as well. In fact it is easy enough to update that I have decided I can keep a blog here. In the past I have written scattered notes here and there on different social media platforms but going forward I'd like to keep everything here on my own website. My new goal in this project is to make a habit of writing short posts on interesting topics and build a collection of thought, ideas, tutorials over time. I will likely write about various topics I am interested in like biotech, nanosensors, and healthcare technology.  In addition, I will be writing posts on some software tools like interesting work flows in emacs including the one I am using to make this very post right now or how to use midjourney to make interesting backgrounds for your website, or using python and NLP to extract detailed technical information from Google Patents, and ...

While this is going to be a multilinqual blog, not all posts will be available in all languages.  My thoughts, experiences and perhaps even my personality is not always identical in environments with different languages, and therefore, the contents of my posts will reflect that reality. 


*** PUBLISH Emacs Workflow: Dynamically Adding Files to Org Agenda :@software:@emacs:@orgmode:
CLOSED: [2023-05-22 Mon 10:32]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files
:EXPORT_FILE_NAME: index
:TITLE: dynamically adding files to org-agenda-files in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to automatically and dynamically build org-agenda-files to include any files with TODO items.
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I'll show you my workflow for automatically adding files with TODO items to org-agenda-files as soon as we open or save the file.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

**** UPDATE Sept. 8 2023

Since I wrote this post, Nicolas Graves has made a GitHub repository that implements this with some improvements using =org-ql= and etc. You can check it out here: [[https://github.com/nicolas-graves/org-dynamic-agenda][org-dynamic-agenda]].

**** Intro

If you use Emacs org-mode for task management, you have probably wondered if there is a way to dynamically add files with TODO items to org-agenda-files. A Google search will likely get you some initial ideas on how to do it. For example this post: [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][Boris Buliga - Task management with org-roam Vol. 5: Dynamic and fast agenda]] covers a good approach, but since Boris's post focuses on using org-roam, it may not be the right solution when you don't use org-roam. So I had to hack my own solution and in this point I'm going to share that with you in case anyone is interested. You can see a [[file:en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamic_org_agenda.gif][screenshot]] below.


**** How does it work

For the main functionalities, I am using [[https://orgmode.org/worg/dev/org-element-api.html][Org Element API]] to parse org-mode buffers and find org TODO items. If there is a =TODO= item in the buffer, and it is visiting a file, I add the file to =org-agenda-files=. Additionally, I make sure that =org-agenda-files= is remembered between different Emacs sessions, I add =org-agenda-files= to =savehist-additional-variables=.

Then I define custom functions for and add them as hooks to org-mode to update =org-agenda-files= when an org-mode file is opened as well as when an org-mode file is saved. The redundancy helps make sure that nothing is lost if there is a crash.


**** The code

- Check if the file contains a =TODO= item:

 Use =org-element-map= and =org-element-parse-buffer= to walk the buffer, find all headlines and return true if there is any headline that is a =TODO= item. Note that I am looking for any heading that is a =TODO= item. Alternatively you can check for specific =TODO= types by looking at =:todo-keyword= instead of =:todo-type= e.g. =(org-element-property :todo-keyword h)...=

#+begin_src emacs-lisp
(defun ad/agenda-file-p ()
    (org-element-map
       (org-element-parse-buffer 'headline)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match))
#+end_src

- make a custom function to update =org-agenda-files= if the current org-mode file contains a =TODO= item:

If the current buffer contains a =TODO= item, I use seq-difference to find out if the files are already in org-agenda-files. If it does not contain =TODO= item, I make sure to remove it from =org-agenda-files=. This is important because when I'm done with a =TODO= item and remove it from the file, I would want the file to be removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-update-files (&rest ARG)
  ;; check if this is an org file buffer
  (interactive)
    (when (and (derived-mode-p 'org-mode) (buffer-file-name))
      (message "updating org-agenda-files...")
      ;; if there is an active TODO task, add this file to agenda files
      (if (ad/agenda-file-p)
      (add-to-list 'org-agenda-files (file-truename (buffer-file-name)))
      ;; if there is no active TODO task, remove the file from agenda files if needed
      (setq org-agenda-files (seq-difference org-agenda-files (list (buffer-file-name))))
      (customize-save-variable 'org-agenda-files org-agenda-files)
      ))
      )

#+end_src

- cleaning up =org-agenda-files= and remove files that don't exist anymore.

When I delete some files, I want to make sure it gets removed from =org-agenda-files=.

#+begin_src emacs-lisp
(defun ad/org-agenda-cleanup-files (&rest ARG)
  (interactive)
  (let ((temp/org-agenda-files org-agenda-files))
  (dolist (file org-agenda-files)
  (if (not (file-exists-p file))
      (setq temp/org-agenda-files (seq-difference temp/org-agenda-files (list file))))
    ())
  (setq org-agenda-files temp/org-agenda-files))
  )
#+end_src

- Adding hooks

To get my functions to run automatically, I add =hooks= to =org-mode=. I make =lambda= functions that are added as hooks to =find-file-hook= and =before-save-hook= to make sure that =org-agenda-files= gets updated whenever I open an org-mode file and then again when I save the file.

#+begin_src emacs-lisp
;; Add or remove individual file
(add-hook 'org-mode-hook (lambda () (add-hook 'find-file-hook #'ad/org-agenda-update-files)))
(add-hook 'org-mode-hook (lambda () (add-hook 'before-save-hook #'ad/org-agenda-update-files)))
#+end_src

- Adding advice to functions that use =org-agenda-files= to show =TODO= items.

Before I run =org-agenda= or =dashboard-get-agenda=, or any other function that reads =org-agenda-files= to show my =TODO= items, I need to make sure to remove non-existing files from =org-agenda-files=.

#+begin_src emacs-lisp
;; remove non-existing files before building agenda
(advice-add 'org-agenda :before #'ad/org-agenda-cleanup-files)
(advice-add 'org-todo-list :before #'ad/org-agenda-cleanup-files)
(advice-add 'dashboard-get-agenda :before #'ad/org-agenda-cleanup-files)
#+end_src

- Make sure =org-agenda-files= is remembered between Emacs sessions.

I add =org-agenda-files= to =savehis-additional-variables= and make sure that =savehist-mode= is enabled.

#+begin_src emacs-lisp
(add-to-list 'savehist-additional-variables 'org-agenda-files)
#+end_src

**** Performance

Of course adding files dynamically to the =org-agenda-files= comes with a cost. Make too many files with org-agenda items and it will be very slow. Personally I keep most of my general =TODO= items in one file under my main org directory and only put =TODO= items in other files when having it in the context of the specific project is useful.

**** Screenshot

Here is a screenshot showing it in action. I open an org file and a =TODO= item in it and save it and as you can see once I refresh the buffer describing =org-agenda-files= variable, the new file is added to the list. I also show that once I remove the =TODO= item or mark it as DONE, it is automatically removed from the list. Also, you can see that once I have the new file in the org-agenda list, it automatically shows up on my dashboard.

#+ATTR_ORG: :width 800px :height nil px
#+ATTR_LATEX: :width 800px :height nil px
#+ATTR_HTML: :width 800px :height nil px
[[file:~/projects/armindarvish-website/content/en/post/Emacs_Workflow_Dynamically_Adding_files_to_org-agenda-Files/dynamics_org_agenda.gif]]

*** PUBLISH Building the Best Blog Editor with Emacs Org-Mode in 2023?
CLOSED: [2023-06-20 Tue 01:23]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Building_An_Efficient_Blogging_Workflow_in_Emacs
:EXPORT_FILE_NAME: index
:TITLE: Building An Efficient Blogging Workflow in Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle How to use org-mode and ox-hugo along with org-todo items and org-agenda to manage your blog posts
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I will show you my custom workflow in Emacs for writing blog posts. I use org-mode for writing the text and ox-hugo for exporting to markdown files. The post focuses on how to create a custom workflow starting with capturing the initial idea with org-capture, then using org-todo and org-agenda to track the post as you take it from idea to an initial draft through different stages of editing to finally publishing it on your website.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: ["software"]
categories: ["software", "emacs", "org mode", "blogging"]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
#+end_src

In the previous post, I showed you how to automatically add files to your org-agenda. In this post I am going to expand on that and show you how to use =org-todo= items beyond tasks and todo lists and build custom workflows. As an example, I am going to show you my blogging workflow. This is what I am using right now to write this post, and in my opinion, it showcases the true power of Emacs and org-mode. If you want to know why Emacs is the one of the best tools for writing blogs in 2023, read on.

But before we get down to the point, let me make one thing clear: This is not a post about the basics of Emacs or org-mode and won't be giving you any configurations for writing text in Emacs either (although I will share some tips and tools as needed), instead it focuses on creating efficient workflows with automation using org-mode features that make Emacs superior to other available tools. Specifically I will show you:
1. Dynamic org-capture templates using Yasnippet snippets
2. Defining functions that are auto-triggered when an org-todo keyword is changed.
3. Some tips on custom org-agenda views to only look at items in a specific workflow
4. Extra tips for improving the look and feel and creating an intuitive user-friendly experience in org-mode
If you don't know much about Emacs or org-mode, or all you are looking for is a list of packages and settings that are useful for wiring non-programming text in Emacs, then I suggest to start elsewhere (You can find lots of good resources here:  [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]]) and come back to this post later, when you feel the need to take your workflow to the next level.

Also, note that while I am using a blog post as an example here, this general approach can be applied to many other scenarios, for example a bunch of flash cards you want to memorize; a selection of books you want to read, digest or summarize; a list of companies you want to apply for a job at; a bunch of projects you want to work on; and so on.

**** Using =org-todo= keywords

By default [[https://orgmode.org/][Emacs Org mode]] comes with two =org-todo= keywords ="TODO"= and ="DONE"= but you can add any custom keyword and use them to track different objects and category of items such as notes, flashcards, ideas, drafts, etc. You can do this by adding the labels to =org-todo-keywords= in a sequence following [[https://orgmode.org/manual/Workflow-states.html][Workflow states (The Org Manual)]]. For example for a blogging workflow I use =(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)")= as shown below. Note that by putting *PUBLISH* after "|", we are setting *PUBLISH* as the done label for this workflow, which can be used for other useful functions such as logging time, etc. (see the section on automating workflow [[Automating the Workflow][below]] for how I use it to automate logging times).

#+begin_src emacs-lisp
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))
#+end_src

Now, we can label org headings as a blog post by adding *DRAFT* todo keyword. This will serve as an entry point to capture ideas for a blog and add it to my agenda to edit later. As I edit the post and decide to publish it on my website, I'll change the label to *POST* or *PUBLISH*. I am going to show you how to use this to create some automated workflow but before that I am going to introduce another tool, Ox-Hugo, that makes it easy to write blog posts in org-mode if you use the static site generator, [[https://gohugo.io/][Hugo]].

**** Ox-Hugo

Next, we look at [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] that allows you to export texts written in org-mode to markdown files that are used by the [[https://gohugo.io/][Hugo]] static generator. If you use Hugo to build your blog, and want to write your posts in org-mode (which you should!), then [[https://github.com/jethrokuan/ox-hugo][Ox-Hugo]] is a natural choice. There are other options such as =org-publish= as well, but I think Ox-Hugo is a better approach.

I recommend you go through Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]] for setting it up and find the specific settings that fit your need. But here are some ideas and tips to consider:

You can organize your blog posts either in separate files (one post per file) or all in one file under different org headings (one post per heading). Personally I am using one post per heading right now because I like to see all my posts in the same file next to each other. But if you prefer having the blog posts in different files, then you may want to consider my previous post [[https://www.armindarvish.com/en/post/emacs_workflow_dynamically_adding_files_to_org-agenda-files/][to dynamically add files to org-agendas]] so that every file gets added to your =org-agenda-files= automatically. Then you can use org-agenda views to browse through all your posts (see [[Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda][below]] for more on that).

Currently, I am using [[https://wowchemy.com/templates/][Wowchemy]]'s [[https://academic-demo.netlify.app/][Academic]] template for my website, so in my ox-hugo configuration, I set everything up according to the structure defined by that template. I use one org file for all my blog posts, and since I have a multilingual site, I put this file in my hugo website's folders under content alongside separate folders for each language. I then set up my ox-hugo to save each post in the appropriate folder by setting =:EXPORT_HUGO_SECTION_FRAG:= property. Because the properties are inherited, I can then use the same property in the subheadings of each post to point ox-hugo to save the post in the appropriate folder. For example for English posts I have something like the following in my file. As you can see I also add =YAML= source blocks for Wowchemy's settings following the documentation here: [[https://wowchemy.com/docs/][Hugo Documentation for Wowchemy]].

#+begin_src org
,* en
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: en
:END:
,** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

## Here I enter new posts##

,* DRAFT Title of the post

:PROPERTIES:
:EXPORT_HUGO_DRAFT: true
:EXPORT_HUGO_SECTION_FRAG: Title_of_the_post
:EXPORT_FILE_NAME: index
:TITLE: Title of the post
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle subtitle goes here
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary summary goes here
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [project]
categories: [tags]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
,#+end_src

#+end_src

I have a separate similar heading tree for other languages. With this setup I can use org-export with ox-hugo to automatically make the markdown files for each post.
Also, since my website is in a git repository, I keep a symlink copy of that file somewhere more convenient in my home folder such as ="~/blog/"= so I can quickly find my posts without navigating through the folder structure of my website.

Other than that there are some site-specific settings that I define in =:PROPERTIES:= drawers following Ox-Hugo's [[https://ox-hugo.scripter.co/][manual]]. I also set up [[https://ox-hugo.scripter.co/doc/auto-export-on-saving/][auto export on saving.]]


**** Automating the Workflow

While the setup above is already great for writing posts in org-mode and quickly exporting them to markdown, we can do much more with org-mode =TODO= items. For example, we can create some automation flow by hooking functions to =org-after-todo-state-change-hook=, so your draft turns into a post on your hugo website automatically when you change the keyword. As a result, you can just focus on writing the contents rather than maintaining the blog files. This is what makes this workflow superior to a lot of other tools, because it brings the automation (that tools like WordPress offer) to a great text-editing environment like org-mode all within Emacs where I personally do a lot of other things (like coding, reading feeds, keeping notes, managing projects and ideas, ...).

*Here is my automated workflow (You can see a screenshot at the end of this post):*

I capture new ideas with org-capture (The next section, [[Using Org-Capture For Blog Ideas][Using Org Capture For Blog Ideas]], will cover how to set this up) under the *DRAFT* keyword and quickly add some rough ideas of what I want to add later. At this point, I rather not have it converted to markdown yet because maybe I end up deciding the topic is not right, and I don't even want to work on it until some other time. Later, when I find time to actually sit down and write up something, I go to my org-agenda list and find the blog post I want to work on and add some more contents and ideas and organize the post. I keep doing this over the next few days or weeks depending on availability until I get to a point when I feel that the content is indeed suitable for a blog post. At this point, I bump the heading to *POST* keyword, which automatically creates the markdown files. I am still not ready to publish this post because I probably don't have figures, and there are still minor details that need fixing. Therefore, in the markdown file, this is still marked as draft (determined by =:EXPORT_HUGO_DRAFT: true= in the properties' drawer), which allows me to see the post on my local web server (e.g. by running =hugo server -D= in the terminal) and decide how to polish and finalize it. Finally, when I'm done with editing the post and want to publish it on my website, I bump the heading up to *PUBLISH* and it automatically flags the post for publishing.

*Here is the code that enables the workflow:*

I have defined a function that changes =:EXPORT_HUGO_DRAFT:= property and also runs =(org-hugo-export-wim-to-md)= for me when I change the keyword.

#+begin_src emacs-lisp
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)
#+end_src

In the code above I am adding a function, =ad/org-change-draft-when-state-changes-to-publis= as a hook to run whenever a =TODO= keyword changes. This function runs =(org-hugo-export-wim-to-md)= to create the markdown files and also sets the =:EXPORT_HUGO_DRAFT:= to =true= or =false= depending on the status. Note that I have hooked the custom function to ='org-after-todo-state-change-hook= which runs on any =TODO= changes but since I am checking the todo state by =(org-get-todo-state)= this hook will only do something when the heading is one of *DRAFT*, *POST* or *PUBLISH*.

There are two more settings for my ideal setup to work as intended:
#+begin_src emacs-lisp
(setq org-log-done 'time
      org-log-into-drawer t)

(setq-default org-export-with-todo-keywords nil)
#+end_src

The code above makes sure that whenever a todo item is set as done (defined by putting the specific =TODO= keyword after ="|"= in the ='org-todo-keywords= list as mentioned [[*Using =org-todo= keywords][above]]). This is useful because ox-hugo uses this log time drawer to add the /"last updated timestamp"/ to markdown files.
Also, I make sure that =org-export-with-todo-keywords= is set to =nil=.

With this setup, I don't need to worry about anything but writing the content. As I change the =TODO= keyword, everything happens automatically in the background. In addition, I have everything set up with [[https://www.netlify.com/?utm_medium=paid_search&utm_source=google&utm_campaign=12755510784&utm_term=netlify][Netlify]] and [[https://github.com/][GitHub]], to automatically update my website when I push new changes to my git repository. As a result, the blogging workflow is as simple as capturing an idea and editing it in org-mode whenever I have time. Everything else happens magically in the background without me having to think or worry about it. Here is a screenshot showing how the new post gets added to the website when I change the keyword from *DRAFT* to *POST*.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/automatic_posting.gif]]

**** Using Org-Capture For Blog Ideas

The next useful step to take is to set up org-capture to quickly save new ideas. Often times blog ideas come to you randomly in the middle of something else, and you don't want to lose them. The org-mode ability to quickly fire up org-capture and write the idea down is therefore a crucial functionality that makes this workflow superior to a lot of other editors. To do this, I use the org-capture with a custom template. You can do this in different ways from minimal setup to more advanced ones, depending on your needs, as I show below.

***** Minimal Setup

You can add a simple template to your org-capture templates following the official instructions: [[https://orgmode.org/manual/Capture-templates.html][Capture templates (The Org Manual)]]. For example, the code below creates a new heading in the ="Blog.org"= file in default org directory under the Heading ="* Posts"=.

#+begin_src emacs-lisp
(add-to-list 'org-capture-templates
      `("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n"))
#+end_src

***** Better Set Up that Adds Ox-Hugo

The simple template above is sufficient for most basic workflows, but I personally like to use something a bit more advanced with automation and add capabilities for ox-hugo. Here is a better template which adds ox-hugo settings:

#+begin_src emacs-lisp
 (add-to-list 'org-capture-templates
      `(("b" "Blog Post" entry
         (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
         "* DRAFT %i %?\n:PROPERTIES:\n :EXPORT_HUGO_DRAFT: true\n :EXPORT_HUGO_SECTION_FRAG: \n :EXPORT_FILE_NAME: index\n :TITLE: \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle \n :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary \n:END:\n\n#+begin_src yaml :front_matter_extra t\nauthors:\n  - admin\nprojects: []\nfeatured: false\ncommentable: true\nimage:\n  caption: 'caption'\n  focal_point: 'center'\n#+end_src\n"
         :empty-lines 1
         :prepend t
         :jump-to-captured t)
#+end_src

The code above adds the ox-hugo settings as =:PROPERTIES:= drawer to your entry and also adds some settings for convenience by =:prepend t= and =:jump-to-captured t=. It jumps to the file narrowed to the heading you just created in case you want to add some more text before finishing the capture process.

***** Advanced Setup with Ox-Hugo + Yasnippet

The template above covers provides all the essentials for an automated workflow, but it is still not the ideal version because but it is not dynamic enough, and some manual editing is still required. For example, I do not want to manually enter the file path for the markdown files. Therefore, in my own setup I take a different approach by using [[https://github.com/joaotavora/yasnippet][Yasnippet]] to do some auto-completion for me. Of course, this means that you need to install Yasnippet and set it up, which may not be what you want and hence the settings above, but in my case I am using Yasnippet for other things anyway, so I might as well use it here.

I define a capture function that calls org-capture but also enables yasnippet and inserts my snippet as a template. This is essentially a from with metadata fields that I can quickly jump to and fill by using the tab button.

#+begin_src emacs-lisp
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))
#+end_src
In the code above I use let-bindings to temporarily define a rather simple =org-capture-template= and call =(org-capture nil "d")= to get the org-capture buffer. Then I achieve the rest of what I need by loading and expanding a yasnippet snippet that contains the following:

#+begin_src emacs-lisp
# -*- mode: snippet -*-
# name: blog post template
# key:
# --
${1:title}
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: ${1:$(string-replace "\s" "_" yas-text)}
 :EXPORT_FILE_NAME: index
 :TITLE: $1
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle $2
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary $3
:END:

,#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [$4]
categories: [$5]
featured: false
commentable: true
image:
  caption: $6
  focal_point: 'center'
,#+end_src
$0
#+end_src

Note how the snippet takes the title and automatically generates the path for the markdown files using =:EXPORT_HUGO_SECTION_FRAG:=. In the screenshot below, you can see my capture process:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/org-capture.gif]]


**** Bonus 1: Quickly see all Your Posts with Custom-Agenda-Views or Consult-Agenda

An advantage of using org-todo keywords for items such as blog posts is that you can then quickly find all your items using [[https://orgmode.org/manual/Agenda-Views.html][Agenda Views]].

#+begin_src emacs-lisp
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))
#+end_src


Alternatively, you can use the awesome [[https://github.com/minad/consult][Consult Package]] by Alexander Miller and use =consult-org-agenda= to quickly search through your blog posts in the minibuffer. Here is some example code you can use after you install consult:

#+begin_src emacs-lisp
(consult-org-agenda "TODO={DRAFT\\|POST\\|PUBLISH}")
#+end_src

Personally, I have built some custom functions based on consult-agenda just for my blog posts that lists all my old posts with status and date, etc. and allows me to add new posts by entering a new title as well. I don't get into all that extra stuff in this post, but it is simply a custom setup for completing-read based on [[https://github.com/minad/consult][Consult]]. It allows me to see my previous posts or start new ones by entering a new title. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/consult-blog.gif]]

**** Bonus 2: Better looks for org-todo keywords

If you want to have some better looks for your org todo keywords, you can check the [[https://github.com/minad/org-modern][Org-Modern]] by Alexander Miller. If you want to have different faces or colors for different labels, you can set =org-todo-keyword-faces= per official instruction: [[https://orgmode.org/manual/Faces-for-TODO-keywords.html][Faces for TODO keywords (The Org Manual)]]. Here is an example:

#+begin_src emacs-lisp
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))
#+end_src


**** Bonus 3: Better Writing Environment inside Emacs

Don't forget to check out other packages that improve the actual content creation and writing texts in Emacs. [[https://github.com/thinkhuman/writingwithemacs][thinkhuman/writingwithemacs: Tips, Examples, and Resources for Writing with Emacs]] is a good collection of articles. Different people have obviously different opinions and take different approaches. [[https://explog.in/notes/writingsetup.html][explog's wirting setup]] is probably a good starting point for any user. Jacob Moena's post on [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/][Creative Writing with Emacs]] provides a more comprehensive intro including some useful extra packages [[https://jacmoes.wordpress.com/2019/09/24/creative-writing-with-emacs/#Extras][here]].

Personally, I think you have to try different packages and find the settings that is appealing to you and your use-case. But here are some suggestions based on my experience.
1. Toggle frame to full screen and hide all other Windows
2. Hide the =properties drawers= that are used for ox-hugo settings, by using =org-fold-hide-drawer-all=.
3. Use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Spelling.html][flyspell-mode]] for spell checking.

Put all of that in an interactive command, and can call it whenever you want to focus on writing:
#+begin_src emacs-lisp
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)
#+end_src
You can also add more settings to this function depending on your preferences. Here are some packages I suggest you try:
1. Consider [[https://github.com/d12frosted/flyspell-correct][flyspell-correct]] and [[https://gitlab.com/OlMon/consult-flyspell][consult-flyspell]] for better, more user-friendly interactive commands with flyspell.
2. Consider [[https://github.com/mhayashi1120/Emacs-langtool][Emacs-langtool]] for checking grammars etc.
3. Consider [[https://github.com/larstvei/Focus][Focus]] mode to get an effect similar to what WordPress calls spotlight.
4. Consider [[https://github.com/cyrus-and/zoom][zoom]] if you open multiple buffers and want the width to adjust dynamically
5. Try out other packages such as [[https://github.com/bnbeckwith/writegood-mode][writegood-mode]] or [[https://github.com/sachac/artbollocks-mode][artbollocks-mode]].

Here is a screenshot of my setup with flyspell, olivetti and focus-mode.

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/focus.gif]]


**** Bonus 4: Seeing Previews with =Hugo Server=

Obviously no good blog editor would be complete without a way to preview the post. If you use Hugo, you can see a preview by running =hugo server= in the terminal which fires up a local server (server default address is http://localhost:1313/). You can achieve the same by using a package like [[https://github.com/masasam/emacs-easy-hugo][emacs-easy-hugo]] from inside Emacs. However, that might be too overkill given that we can already do most of the functionality with org-mode and ox-hugo. Personally, I have defined a function that calls =hugo server= as a process within Emacs and a second function to kill the process.

#+begin_src emacs-lisp
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )
#+end_src

Note that the arguments =-buildDrafts= and =--navigateToChanged= are passed to =hugo server= to make sure you see your drafts and also automatically navigate to the most recent changes.
If you also have xwidget-webkit in your Emacs, then you may want to create another interactive command to open the page in a second buffer like below. If you don't have xwidget, you can use any other browsers for example by invoking =browse-url= to open the link in an external browser.

#+begin_src emacs-lisp
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src

This opens the local hugo server and navigates to the page for the post in the current buffer. Since we have =--navigateToChanged= turned on, as we edit the text we can see the changes right away. Here is a screenshot:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/preview.gif]]


**** Putting everything together: Code and Screenshot

Here is a screenshot that shows the complete workflow:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Building_An_Efficient_Blogging_Workflow_in_Emacs/full_workflow.gif]]


and here is my preferred entire code (see the post for some alternatives if you don't have/want all the required extra packages below):

#+begin_src emacs-lisp

;; org-todo keywords
(add-to-list 'org-todo-keywords '(sequence "DRAFT(d)" "POST(p)" "|" "PUBLISH(b)"))

;; org-todo faces
(add-to-list 'org-todo-keyword-faces
      '("DRAFT" . '((t :foreground "pink"))))


;; function(s) to run on changing state
(defun ad/org-change-draft-when-blog-state-changes ()
  (interactive)
  (pcase (org-get-todo-state)
    ("PUBLISH" (org-set-property "EXPORT_HUGO_DRAFT" "false")
     (org-hugo-export-wim-to-md))
    ("DRAFT" (org-set-property "EXPORT_HUGO_DRAFT" "true"))
    ("POST" (org-set-property "EXPORT_HUGO_DRAFT" "true")
            (org-hugo-export-wim-to-md))
    (_ ())
    )
  )

(add-hook 'org-after-todo-state-change-hook
'my/org-change-draft-when-state-changes-to-publish)


(setq org-log-done 'time
      org-log-into-drawer t)

;; make sure org-todo keywords don't get exported
(setq-default org-export-with-todo-keywords nil)

;; capture function for blog posts
(defun ad/blog-capture-new (&optional text)
(interactive "sTitle: ")
  (let* ((org-capture-templates `(("d" "default" entry
                                   (file+olp ,(file-truename (expand-file-name "Blog.org" org-directory)) "Posts")
                                   "* DRAFT %?"
                                   :empty-lines 1
                                   :prepend t
                                   :jump-to-captured t)
                                  ))
         (yas-wrap-around-region t))
    (org-capture nil "d")
    (let ((draft (and (yas-reload-all) (yas-lookup-snippet "hugo draft" 'org-mode t))))
        (yas-minor-mode-on)
        (yas-expand-snippet draft)
        (insert (format "%s" text)))
      ))

;; custom org-agenda view
(add-to-list 'org-agenda-custom-commands
     '("b" "Blog"
        ((agenda)
         (todo "DRAFT\\|POST\\|PUBLISH"
               ((org-agenda-overriding-header "Blog Posts: "))))))

;; enable extra packages for focusing on writing
(defun ad/blog-focus-writing ()
(interactive)
(toggle-frame-fullscreen)
(delete-other-windows nil)
(org-fold-hide-drawer-all)
(flyspell-mode 1)
)

;; start the hugo server with Drafts and navigateToChanged
(defun ad/blog-start-hugo-server ()
  (interactive)
  (let ((default-directory "/path/to/your/blog-hugo-server/directory") ;;change the path to your website
        (buffer (get-buffer-create "*blog-hugo-server*")))
    (apply 'start-process "hugo-server" buffer "hugo" "server" '("--buildDrafts" "--navigateToChanged"))
    )
  )

;; stop the hugo server process
(defun ad/blog-kill-hugo-server ()
  (interactive)
  (when-let ((proc (get-buffer-process (get-buffer "*blog-hugo-server*"))))
    (delete-process proc))
  )

;; get a preview of new drafts
(defun ad/blog-preview ()
(interactive)
(unless (get-buffer-process (get-buffer "*blog-hugo-server*"))
  (ad/blog-start-hugo-server))
(let* ((post-url (downcase (org-hugo--entry-get-concat (point-marker) "EXPORT_HUGO_SECTION_FRAG" "/"))))
(delete-other-windows nil)
(split-window-right nil)
(other-window 1)
(xwidget-webkit-browse-url (concat "http://localhost:1313/" post-url))
))
#+end_src


*** PUBLISH Consult-GH: Working with GitHub inside Emacs in 2023
CLOSED: [2023-06-26 Mon 04:49]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: consult-gH_working_with_gitHub_inside_emacs_in_2023_
:EXPORT_FILE_NAME: index
:TITLE: Consult-GH: Working with GitHub inside Emacs in 2023
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle Introducing a new package for using GitHub interactively inside Emacs based on Consult, Embark and GitHub CLI
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary This post introduces my new Emacs package that uses the fabulous Consult and Embrak along with GitHub CLI tool to create an intuitive user-friendly interface for GitHub inside Emacs
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
tage:
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

**** Introduction

This section addresses the question of "why do we need yet another package?" If that is not of interest to you, skip to the next section and look at the examples and demos.

***** What is the need? Why make a new package?

I often find myself browsing GitHub for various reasons. Sometimes I go back to a package repo to read the documentation/manuals for installing or troubleshooting. Other times I browse the repositories by users whose works are of interest to me (for example [[https://github.com/purcell/emacs.d][Steve Purcell's Emacs Config]] or [[https://github.com/alphapapa][alphapapa (Adam Porter)]]'s packages for org-mode workflows). This is often done by doing a Google search finding the relevant GitHub Page and navigating from there to find the right content. It would have been great if I could do all of that from inside Emacs especially if I could then take some code from those repositories, paste it in an org-mode source block or a REPL and see how it works. But, as far as I know, no Emacs package provides a user-friendly intuitive interface for such functionality. While there are multiple packages that interface with GitHub API like [[https://github.com/sigma/gh.el][gh.el]], [[https://github.com/magit/ghub][magit/ghub]], [[https://github.com/magit/forge][magit/forge]], [[https://github.com/sshaw/git-link][git-link]], [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] and ..., none of them provide the kind of functionality I am looking for.

Let's take a closer look at some of these to better understand where the gap is.

On one end of the spectrum, we have a package like [[https://github.com/sigma/gh.el][gh.el]] which seems to be an interesting option with a huge code base possibly covering a lot of low-level API calls to GitHub, but there is not a single line of documentation on how to use it! The repo seems to be abandoned years ago, and the owner mentions on one of the issues that *"the whole thing was a gigantic experiment around the viability of eieio, and I'm pretty disappointed by the amount of suffering it generates, so I'm not sure I should push people to use it..."*. This is clearly not the right solution to use in 2023!

On the other end of the spectrum, we have packages like git-link and browse-at-remote that are relatively small (<1000 lines of code), but the functionality is very limited, getting the URL links for files and commits, etc. While these are very useful, especially because they cover sources other than GitHub too, they don't really provide a way to browse repositories or issues or search for new content.

Then there is of course magit packages, that are indeed incredibly useful for doing =git= commands from inside Emacs, and it provides extended functionality in extra packages such as magit/forge to interface and work with issues and pull requests on multiple repository sources. However, this is geared toward repositories you actively work on and not so much toward browsing/finding new content. In other words, magit/forge does not provide simple interactive commands to find repositories or browse their content on demand without first cloning them or adding them to its database.

In addition, all of these packages were started several years ago, and since then there has been updates in Emacs as well as other tools like GitHub CLI that provide new opportunities for how we can interface with GitHub from inside Emacs. This is exactly what consult-gh is trying to do.

***** How does consult-gh do it?

The principle idea in consult-gh is that I only focus on providing what is missing and leave the rest to existing tools that provide the basic functionalities. For example, the [[https://github.com/cli/cli][GitHub CLI]] (=gh= commands in the terminal) is the right tool to use for interfacing with GitHub. After all it is the official CLI tool. By leaving jobs such as authentication and API calls to =gh=, we simplify the code and make it really easy to set up and use. In addition, we make the code more secure since we don't have to handle authentication tokens and at the same time we keep the code more maintainable because we don't have to worry about keeping up to date with the API, etc.
For comparison, if you set up magit/forge and go through all the steps you need to do to interface with GitHub, you'll see while leaving this job to a tool like =gh= might be a better approach for consult-gh (obviously in case of magit/forge that's not an option since it supports sources other than GitHub).

On the other hand, =completing-read= inside Emacs provides a perfect tool for interfacing with users and running queries, etc. and in recent years, there has been great improvements especially with a package like [[https://github.com/minad/consult][consult]] that wraps around completing read and provides easy to use features. Along with the rest of completion framework packages ([[https://github.com/minad/vertico][vertico]], [[https://github.com/oantolin/embark][embark]], [[https://github.com/oantolin/orderless][orderless]], ...), they provide a great tool set for functions that need input form users. Therefore, by bringing =consult= and =gh= together, we can easily provide a concise, yet powerful tool that improves on the current alternatives for interacting with GitHub inside Emacs.

That said, let's keep in mind that the goal here is not to replace the existing functionalities with yet another tool but fill the gaps between the current tools. For example, consult-gh does not provide (at least not yet) a way to edit issues or pull requests because that functionality is available in magit/forge for not just GitHub but also other sources, so I don't see any benefit in duplicating that in consult-gh (unless of course somebody convinces me otherwise!)

Another important factor to consider is that when it comes to interacting with repositories, there is a vast range of actions and commands, and different people would use it in different ways and that means we need a customizable tool that can mold to the users' desires. Naturally, it is difficult to come up with a one-size-fits-all solution and as a result a lot of tools that try to do this get bloated or fail to provide benefits compared to going back to the browser, and therefore they don't stick. Emacs, however is a general tool with small packages that cover specific tasks very well and typical Emacs users often don't mind spending some time to tinker with configurations and build their own custom workflows. Therefore, inside Emacs we can build on available packages and tools that users will be using anyway and provide new functionalities with enough customizability that makes the overall experience better than "just the browser" or "gh" without creating a completely new tool that is bloated and hard to learn from scratch.

This is what I am trying to create with consult-gh. To do so, I am trying to balance between usability (a.k.a. having many commands for different use-cases and scenarios) and utility (being more efficient in practice for typical workflows than using a browser for example). To do so, I am providing *only a handful of interactive commands* to keep things simple, intuitive and easy to use, yet I am offering a range of customization to tweak the behavior so that the user can pick what is most useful in their day-to-day use. For example, the user can fetch a list of repositories matching a search term by running the command =consult-gh-search-repos=, but the action that happens after selecting a target repository is customizable. By default, I provide a few useful functions for typical users, and allow advanced users to define their own custom commands if they wish to do so. If all the user wants is to open the URL of a repository in the browser, that is provided by default. If they want to view the README in an Emacs buffer, or see branches and browse the files they can do so by adding one line to their configuration. They can also choose to clone or fork the repository with one line of configuration. I also provide examples of [[https://github.com/oantolin/embark][Embark]] actions that can be used to do multiple commands on repositories and more. This should cover most of the typical use-cases, but if the user still needs something more complex beyond those actions, they can write their own custom commands and set them as default action to run when a target repository is selected. In other words, typical users can get the typical functionalities they use on a daily basis in a browser inside Emacs, hence better efficiency and customization. Advanced users, can come up with actions that are not possible in a browser and are hard to dynamically implement without a lot of scripting from scratch. Therefore, the balance between usability and utility should always be met no matter what the user is looking for.

**** How is Consult-GH Useful

If you read the Intro, you may be thinking, that is a lot of vague ideas that sound interesting on paper but in reality what can consult-gh do that is better than using a browser or just =gh= itself. "Can you convince me that this is not just another shiny tool that looks nice but does not provide any meaningful new feature or functionality?". In this section I am going to provide examples of use cases with context before we get down to codes and demos and how-to instructions in the next parts. Again, if this is not of interest to you, and you just want to see the examples in action and demo videos, jump ahead and see the next parts, otherwise keep reading.

There are a few GitHub accounts that I tend to keep going back to either because I am looking for some new tool or functionality I need or because I am trying to learn from their code, implementation and general approach. Before making consult-gh, my workflow for this was:

1. _Find the Source_: Do a Google search (for example to find "Steve Purcell Emacs config") or open a bookmark (for example the GitHub repo of [[https://github.com/dakrone/eos][emacs operating system]])
2. _Find the relevant content_: For example by browsing through the files on a GitHub repo or looking at recent updates, commits, etc.
3. _Understand the Content_: This would usually require, copying code from the browser back to a REPL or IDE and interact with it and run examples to figure out what each part does etc.
4. _Implement my own solution_: Finally, I have to decide if I would like to use the content I just learned in my own projects. For example, after looking at "Steve Purcell's Config" I need to decide whether I want to use some parts of it in my own config and if so how do I need to adjust and use it.

This is not very efficient because the tools I was using were not specifically designed for this. For example, Google is a great "general" search engine but if I want to go back to the same page on *eos* GitHub repo then, I probably have to bookmark that page. But as you may have experienced that would mean that I end up with many bookmarks, and now I need another tool to search through my bookmarks to find the right page, and sometimes I don't remember which bookmark was the right one, and I perhaps have to go back and look at my notes if I took any and so on.
Moreover, when I finally find the source and content of interest, I am likely looking at some code in a browser, where syntax highlighting is often suboptimal; no IDE or REPL is available to run and explore the code; help and documentation is not available to parse different pieces of the code; etc. Compare this with looking at code inside Emacs, where you can easily run snippets of codes to test and understand functionalities either by jumping to a REPL or by running code inside an org-mode source-block. In addition, at least in case of elisp code, help and documentation is always just a =C-h= key away! Such documentation is often proven extremely useful especially if you also use a package like [[https://github.com/Wilfred/helpful][helpful]]. For non-elisp code, the chances are you can also find documentation, debugging and other tools inside Emacs by installing the right packages. Finally, when it comes to implementing my own solution, this would mean either copying code from the browser into a local file or forking/cloning the repository and then editing the code which means I would leave the browser and would go to an IDE tool such as Emacs.

Wouldn't it be great if I could do all of that inside Emacs to begin with? For example, let's say I am looking at [[https://github.com/purcell/emacs.d/][Steve Purcell's Emacs Config]] but instead of doing that in the browser, I can pull up the relevant repository and browse the files all from inside the Emacs. If I see a piece of code I am interested in I can copy it to and org-mode source block and see what it does. If I need help and docs I can look things up in Emacs. I can do all of that without even cloning the repo. For another example, consider the scenario where I want to look at recent works from [[https://github.com/alphapapa][alphapapa]], see what new projects and repositories he has been working on. I can open his GitHub page in the browser and manually go over his more than 700 repos to find out, but wouldn't it be great if I could get a list of all his repos within Emacs, and search through them and interactively see README files? Then, if I see something of interest browse the files, or clone the repo and take things for a test drive all from within Emacs?

If your answer to those questions is yes or any of what I said rings a bell, then you will likely be interested in consult-gh and what I am about to show you in the next sections.

**** Features and Demo

In this section, I will show you examples of using consult-gh to interact with GitHub from within Emacs. The goal is to show the basic features and explain how things work and then provide examples of meaningful workflows that are more efficiently done with consult-gh than opening a browser or using other tools. Please note that I do not intend to go through all the details of installation, customization, configuration etc. here. Instead, I focus on showing the functionality. For instructions please refer to the documentation on the official [[https://github.com/armindarvish/consult-gh][consult-gh]] page.

***** Searching Users/Organization

In the previous section I mentioned an example of looking at [[https://github.com/alphapapa][alphapapa]]'s repositories. Let's see how that would work with consult-gh. As you will see in the video below, you can run the interactive command =consult-gh-orgs=, enter a GitHub username and see a list of their repositories. One nice feature is that you can also enter multiple usernames by using a crm-separator, and see all their repositories at the same time grouped by usernames.

Then depending on configuration (see the next section for details), you can do a number of different actions. For example, you can choose to see a preview (a.k.a. the README file inside an Emacs buffer), or see the file contents inside Emacs. In the video below I have turned preview on and set the action to show the file contents. I'll show you how to do that in the next sections but for now here is a demo of how it looks.

#+begin_export hugo
{{< youtube id="hSIqElbJlV8" title="Search GitHub Users and See Their Repos" >}}
#+end_export

In the video above, I show a few examples of searching user accounts to retrieve their repositories. I first show searching for single or multiple usernames and seeing previews of repos (a.k.a. *README* file) inside Emacs. Then I show the completion in minibuffer can make it faster to find relevant repos especially from users who have many repositories. Keep in mind that if loading a lot of repositories slows things down, you can always set the max number of results for repositories (per account not total) by setting =consult-gh-repo-maxnum=.

****** Looking at a Default List of Repositories

You can also look at a default list of usernames to =consult-gh-default-orgs-list= and use =consult-gh-default-repos= to see their repositories. You can add any GitHub usernames to the list, but I use this to quickly open my own repos inside Emacs. Note that since we are using =gh= on the back-end, this can show private repositories of the account that is logged in as well.

***** Searching Repositories

More often than looking for specific users, I look up specific packages (e.g. org-roam, lsp-mode, ox-hugo, ...) to check manuals and documentation. Similar to what I mentioned above, before consult-gh, I would have used Google and a browser, but now I use most of it in consult-gh. Let's go through an example to see the functionalities.

Let's say I want to look at ox-hugo's documentation for [[https://www.armindarvish.com/en/post/building_an_efficient_blogging_workflow_in_emacs/][my blogging workflow]], or want to look at org-roam for my note-taking. In this case, I can use the interactive command =consult-gh-search-repos= and enter a search term.  When I search for =ox-hugo=, I get a number of hits, and then I can choose the one I am looking for.

Now, let's go through some useful features and how to use them:

****** Previewing Repos

By default, previews are off because previewing a repo requires downloading the README file and that can be slow depending on your environment and network speed, etc. But in my config, I have turned consult-gh's previews on. I have also set the preview-mode to ='org-mode=. By default, this is set to ='markdown= to preserve the contents since most README files are =.md= format, but I convert it to org-mode because this makes it much easier for me to see source-blocks, etc. and evaluate them inside Emacs.

#+begin_src emacs-lisp
(consult-gh-show-preview t)
(consult-gh-preview-buffer-mode 'org-mode)
#+end_src

With this setting, when I move the cursor to a repo in the minibuffer I see the README in org format in a preview buffer and I can read the contents. This is similar to visiting the homepage on GitHub except that I can also see codes with syntax highlighting, I can evaluate code in source blocks, and ... without leaving Emacs. Since loading previews can be slow, you may want to do this on demand. You can do that by turning previews on and binding =consult-gh-preview-key= to a specific key. In the example below I turn the preview on and bind it to =M-o=.

#+begin_src emacs-lisp
(setq consult-gh-show-preview t)
(setq consult-gh-preview-key "M-o")
#+end_src

Here is a video to show the preview on demand functionality.

#+begin_export hugo
{{< youtube id=mqsFIP_j_kg title="Consult-GH: Preview on Demand" >}}
#+end_export

****** The Default Action and Some Options

Now if I hit enter to select a repo, then the action function that is bound to the variable =consult-gh-repo-action= is run. By default, this is bound to the function =consult-gh--repo-browse-url-action= which opens the GitHub page in the browser, but you can change the default function to other functions provided such as browsing files, cloning, forking, browsing issues or some other custom function. Personally, I have changed it to =consult-gh--repo-browse-files-action= which allows me to browse the files inside Emacs. Here is my config:

#+begin_src emacs-lisp
(consult-gh-repo-action #'consult-gh--repo-browse-files-action)
#+end_src

Note that this only fetches the file tree and does not download the files. If you open the file (or preview it in a buffer), then that single file is downloaded into the system temporary directory. This way, you will only download the contents you want to see and store them temporarily.

There are other actions that are provided by default, and you can use them as default action by setting =consult-gh-repo-action=. These actions include cloning, forking, copying relevant links to kill-ring (e.g. homepage, https or ssh links, or org-mode link). In addition, I provide an example that copies a drop-in snippet with =straight.el= and =use-package= to kill ring. I can paste this snippet in my Emacs config to install the package! Here is a video of that shows the repo functions in action:

#+begin_export hugo
{{< youtube id="B8hxrMLx1TM" title="consult-gH: repo actions" >}}
#+end_export

****** Embark Integration

In addition to the default action, you can use alternative actions by using [[https://github.com/oantolin/embark][embark]]. The [[https://github.com/armindarvish/consult-gh/blob/main/consult-gh-embark.el][consult-gh-embark.el]] file provide some example of how to do this. Here is an example showing how to bound =c= to embark action for cloning the repo:

#+begin_src emacs-lisp
(defun consult-gh-embark-clone-repo (cand)
  "Clone the repo at point."
  (funcall (consult-gh--repo-clone-action) (get-text-property 0 :repo cand)))

(defvar-keymap consult-gh-embark-actions-map
  :doc "Keymap for consult-gh-embark"
  :parent embark-general-map
  "c" #'consult-gh-embark-clone-repo)

(add-to-list 'embark-keymap-alist '(consult-gh . consult-gh-embark-actions-map))

#+end_src

With the embark integration, you can have a quick way for doing alternative actions on items (repos, files, issues, etc.) You can also define other custom functions and bound them to embark's keymap following the same patterns as those provided.

In the video below, you can see examples of using embark integration.

#+begin_export hugo
{{< youtube id="nI00g6IdMyg" title="Consult GH: Embark Integration" >}}
#+end_export


***** Finding Files

The next example is using =consult-gh-find-file=. This is a quicker way to see files if you already know the name of the repository. For example, you can enter =minad/vertico= and browse the contents. Similarly to what was mentioned for repos, you can also run different functions on files. By default, consult-gh opens the file URL on GitHub when you select it, but you can configure it to open the file in Emacs. This makes an API call and downloads the file contents, so it may be slow for large files but in my tests so far the speed has been great even for some large files.

Here is a configuration to set consult-gh to open files inside Emacs.

#+begin_src emacs-lisp
(consult-gh-file-action #'consult-gh--files-view-action)
#+end_src
When you set the function to browsing files, consult-gh asks you to select a branch by default, but you can change the setting (see documentation on [[https://github.com/armindarvish/consult-gh#consult-gh-default-branch-to-load][consult-gh-default-branch-to-load]] variable).

As mentioned above, previewing a file will also fetch the contents, and therefore you may want to limit previews to on-demand only by setting a preview key.

#+begin_export hugo
{{< youtube id="bavnpbnDJIQ" title="Consult-GH: Browse GitHub Repo Files inside Emacs" >}}
#+end_export

***** Searching Issues

In addition to repos and files, you can also browse issues with =consult-gh-search-issues=. You first asked enter a search term for issues (and you can pass an empty string if you want to see all issues of specific repos), then you are asked to enter name of repos (in =user/repo= format for example =armindarvish/consult-gh=). You can pass an empty string to this and consult-gh will search for issues in any repo. Furthermore, you can set the =consult-gh--issues-state-to-show= to =open=, =closed= or =all= to change the issues that are shown. Similar to what was mentioned for repos and files, you can then run different actions on issues. By default, the action is set to =consult-gh--issue-browse-url-action= that opens the URL in a browser, but you can also change that to =consult-gh--issue-view-action= to see the issue inside an Emacs buffer.

Here is a demo:

#+begin_export hugo
{{< youtube id="DbRmd75Ywt8" title="Consult-GH: View GitHub Issues inside Emacs" >}}
#+end_export

***** Taking it to the Next Level

The examples above showed uses that are common for many users on a daily basis. But there are a lot more you can potentially do by using consult-gh.

****** Working with Multiple Repos All at Once

Moreover the integration with embark allows some more complex functionalities such as working on multiple repos or files. For example, if you want to clone a bunch of different repos, instead of navigating to GitHub and getting the links and running =git clone= commands, you can just search multiple accounts with =consult-gh-orgs= or multiple repos with =consult-gh-search-repos= using =consult-gh-crm-separator= and then clone all of them at once.

Let's say I want to look at all the repos by alphapapa and clone a few of them that are related to org-mode. Now since alphapapa has over 700 repositories in his account, I first need to increase the maximum number of results I normally get:

#+begin_src emacs-lisp
(setq consult-gh--repo-maxnum 1000)
#+end_src

Then I can run =consult-gh-orgs= and look for =alphapapa=. This takes some time to load all the repositories, but this is way faster than browsing through GitHub to find the repositories manually. Then in the result I search for ="org-"= and run embark select (bound to =SPC= by default) and once I select everything, I run embark act on all (bound to =A=) plus the consult-gh-embark-repo-clone (bound to =c= in my setup). By default, consult-gh will go through every repository and confirms the repo I want to clone and the path, etc. But if you happen to do this often, you can configure consult-gh to always clone the repositories in a folder where you keep your repositories (e.g. "~/code" or "~/projects") and then set =consult-gh-confirm-before-clone= to nil:

#+begin_src emacs-lisp
(setq consult-gh-default-clone-directory "~/code")
(setq consult-gh-confirm-before-clone nil)
#+end_src

With this setting consult-gh just clones the repositories with the repo's default name under ="~/code"= folder. Browsing GitHub in the browser or using =gh= in the command line will never be this fast!

****** Actions on Multiple Files (e.g. Comparing Files)

In addition to viewing files, you can also select multiple files by using =embark-select= and run a function on multiple files, for example if you want to download a selection of files without cloning the whole repository. In addition, you can use a crm-separator and search for multiple repos (or the same repo multiple times and select different branches) and then compare files (for example with =ediff= or [[https://github.com/justbur/emacs-vdiff][emacs-vdiff]]). This can be done without cloning the repo or even permanently saving the file on your local machine (by default consult-gh loads previews by downloading files in the system's temp directory). Similarly, you can use embark-select and embark-act-all to run commands on multiple files possibly even from different repos or from different branches of the same repo.

The video below demos some potentially interesting use cases.
#+begin_export hugo
{{< youtube id="_b6FYACa4Fw" title="Consult-GH: Interact with Multiple GitHub Repos or Files inside Emacs" >}}
#+end_export

****** Extending Functionality with Custom Functions

Advanced users who don't mind writing a few lines of code to build custom workflows can further expand on the built-in functionalities by mixing different functions and actions. For example, let's say you want to add the same file (e.g. a new LICENSE) to multiple repos. You can create a custom function that clones the repo, adds a file, commits the changes and pushes to the remote. With the right packages already installed, this will only be a few lines of code in elisp. Then you make an embark action similar to examples provided in [[https://github.com/armindarvish/consult-gh/blob/main/consult-gh-embark.el][consult-gh-embark.el]]. Now you can search GitHub, select any repo (or multiple ones) and run this command on them! Isn't that neat?

In fact let me just try to write the code for that specific example with the simplest implementation right now:

#+begin_src emacs-lisp
(defun consult-gh-clone-and-add-file (repo file &optional clonedir)
  (let* ((clonedir (or "~/tmp/code" clonedir))
        (reponame (car (last (split-string repo "\/"))))
        (filename (file-name-nondirectory file))
        (newname (expand-file-name filename (expand-file-name reponame clonedir))))
  (consult-gh--repo-clone repo clonedir reponame)
  (copy-file file newname t)
  (expand-file-name reponame clonedir)))

(defun consult-gh-embark-clone-and-add-file (cand)
  "Clone the repo at point."
  (let* ((repo (get-text-property 0 :repo cand))
        (file (read-file-name "Select File: "))
        (repodir (consult-gh-clone-and-add-file repo file))
        (default-directory repodir))
    (shell-command "git add .")
    (shell-command (concat "git commit -m \"" file " added\""))
    (shell-command "git push origin main")))

(defvar-keymap consult-gh-embark-actions-map
  :doc "Keymap for consult-gh-embark"
  :parent embark-general-map
  "v" #'consult-gh-embark-clone-and-add-file)

(add-to-list 'embark-keymap-alist '(consult-gh . consult-gh-embark-actions-map))
#+end_src


That is 30 lines of code (and could possibly be optimized since I just wrote it in 5 minutes) that allows me to do something quite complex. Of course in Emacs, there might be other better ways to achieve this specific task, but this shows you how you can quickly build custom workflows with consult-gh.

**** Future Ideas

There are a few other ideas that I have in mind and I may implement them in the future as time allows and would welcome anybody that would like to contribute to these or potentially other interesting ideas:

1. I would like to provide a simple interface for multiple profiles. This should be easily achievable using environment variables like GH-CONFIG-DIR, but I still need to decide what would be the right way of implementing it. Should this be a global variable in consult-gh or shall we define local per buffer variables, etc.

2. I think we can improve the current interface of =consult-gh-find-file= to make it behave more like find-file in Emacs where folders are expanded dynamically as the user makes step-by-step selections to navigate the folders. This is however not the best approach for looking at files in multiple repos, so I may have to keep the current approach for multiple repos, but I'd love to hear suggestions on that. I briefly talked to Daniel Mendler (the owner of the consult repo) and it seems that there are good ways of implementing a dynamic completion table for file-names with consult. However, so far between my limited elisp skills and lack of good in-detail documentation on Emacs completion tables, I have only had partial success with it and there are still many quirks to deal with. So this may take some time to implement.

3. The =gh= command in the terminal provides additional arguments to further filter search results for example to filter issues by date or tags, etc. This is not yet implemented in consult-gh. I think it can be added by some minimal effort if I enable extra arguments in some of the calls to gh (that I can of course turn into a rabbit hole that takes weeks, but I think it'd be doable at the end anyway). However, I am not yet convinced that this will add much value. I think having too many options can negatively affect the user-friendliness and efficiency of the package. There is always going to be some use-cases for which jumping to the browser would be a better option after all. I'd be interested to hear counterarguments if any though especially if there are ideas for clean and simple interface that allows using such options with an intuitive interface.

**** Links

- YouTube Playlist: [[https://www.youtube.com/playlist?list=PLLKxLZdx_YyZdW4CidqbVPJjyo396Y1cx]]
- GitHub Repository: [[https://github.com/armindarvish/consult-gh]]

*** PUBLISH Use Emacs as a ChatGPT App from Anywhere on Your System
CLOSED: [2023-06-22 Thu 18:44]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Use_Emacs_as_a_chatgpt_client
:EXPORT_FILE_NAME: index
:TITLE: Use Emacs as a ChatGPT client from anywhere on your system
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post, I will show you how you can quickly make a chatgpt/bing client inside emacs that you can call from anywhere on your system (e.g. spotlight search on macOS)
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
categories: [software, ChatGPT, Emacs]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

In this post, I will show you how you can easily create a ChatGPT app on your system using the existing packages for ChatGPT in Emacs and call it from anywhere on your system. If you are on a system where you don't have an app (like macOS or Linux) and don't like to using the browser, this might be a good way of using ChatGPT plus the fact that you can integrate this with all sorts of other things you can do inside Emacs.

**** ChatGPT Clients in Emacs

There are a number of packages for ChatGPT client inside Emacs and I have tested a few of them so far. In my opinion, Karthik Chikmagalur's [[https://github.com/karthink/gptel][gptel]] is the best one both in terms of functionality and ease-of-use and also in terms of implementation and staying true to Emacs way of doing things. Therefore, if you are not interested in testing things out, just go ahead and use gptel and you can skip the rest of this section. There is a good (but long) live stream by David Wilson on System Crafters channel if you want to see gptel in action: [[https://www.youtube.com/watch?v=JImYEdqVQR8][Crafting the Future: AI Assistants in Emacs - System Crafters Live! - YouTube]].

If you want to know more about different packages, here are some notes:

***** GPTel

As I said above [[https://github.com/karthink/gptel][gptel]] is the best client I have tested so far. It is simple, does not have weird dependencies or authentication process, and provides an emacs-like experience (e.g. works in any buffer, does not create a million different buffers, ...) It is fast and async, and installation is straightforward since it is on MELPA. The code itself is also clean and easy to read, if you want to tinker with it and create your own custom functions or macros.

***** emacs-aichat

emacs-aichat]] works as expected but is not as clean in implementation as gptel. It does offer the option to use Microsoft's BingAI instead of ChatGPT but otherwise is not as good as gptel. It uses [[https://github.com/ahyatt/emacs-websocket][emacs-websocket]] and [[https://github.com/chuntaro/emacs-async-await][emacs-async-await]] which adds extra dependencies and the way the code is implemented there are many layers of functions and macros calling each other even though at the end it is using =url-asynchronous= to make calls to APIs. There are duplicates of similar functionalities for BingAI v.s. OpenAI's ChatGPT and different ways to do authentication or setup for them. As a result the code is complicated to read and debugging (which is expected with experimental packages like this) or building on top of it is not as easy. That said the author is quite responsive and has been improving things frequently.

***** openai and chatgpt

You can take a look at [[https://github.com/emacs-openai/openai][openai]] and [[https://github.com/emacs-openai/chatgpt][chatgpt]], and other related packages by Jen-Chieh Shen.  [[https://github.com/emacs-openai/openai][openai]] provides low-level calls to OpenAI API and [[https://github.com/emacs-openai/chatgpt][chatgpt]] builds on top of that for using the ChatGPT. The author has also other packages for other OpenAI services. I think the implementation is very neat and everything is done in a modular way, so this is a good reference if you want to learn and perhaps even build your own ChatGPT client inside Emacs. That said, I personally don't like the interface of the [[https://github.com/emacs-openai/chatgpt][chatgpt]] package. It opens up new buffers for inserting queries and does not play well with evil-mode. The gimmicky UI elements like spinners and so on seem unnecessary. They do not provide extra functionalities and are not pretty enough to add value to the user experience either. I think if you spend enough time configuring the package and trimming things up, this can be a decent ChatGPT client, perhaps with more features than some other packages I've tried, but I prefer a simpler interface that are faster and more user-friendly.

***** org-ai

[[https://github.com/rksm/org-ai][org-ai]] takes a different approach to interacting with ChatGPT (and in this case also DALL-E) and that is by using source blocks inside Emacs org-mode. I tried it shortly and decided that I personally prefer other approaches. The reason is inserting ChatGPT responses inside an org source block means that the code blocks in ChatGPT responses are now nested inside another code block which is not useful. I probably would have preferred if the response was returned as result (similar to [[https://github.com/suonlight/ob-chatgpt][ob-chatgpt]] below). Also, I don't think a conversation with AI using natural language really belongs in a source block (which is really designed for coding). But that's just my personal opinion. I can see how some people may prefer this over other approaches. You can try it yourself and see if it fits your use case.

***** ChatGPT.el and ob-chatgpt

Josh Cho's [[https://github.com/joshcho/ChatGPT.el][ChatGPT.el]] is perhaps the worst approach among the ones I have tried. The implementation is unnecessarily complicated. It uses python and [[https://github.com/mmabrouk/chatgpt-wrapper][chatgpt-wrapper]] under the hood to interface with OpenAI API and all it really does is to run a =shell-command= that does =pip install chatgpt-wrapper=. The authentication process uses an external browser and is very clunky and often requires re-authentication because it is using chatgpt-wrapper under the hood which runs python scripts. In addition, there is Minh Nguyen-Hue's [[https://github.com/suonlight/ob-chatgpt][ob-chatgpt]] which is built on ChatGPT.el but uses org-babel source blocks instead. Since it is using ChatGPT.el, it has all the issues of ChatGPT.el as well.

**** Configuring GPTel

Install [[https://github.com/karthink/gptel][gptel]] following the official documents, then all you have to do is to set up your API key by setting =gptel-api-key= and you are good to go. You can call the interactive command gptel by =M-x gptel= and you will jump to a ChatGPT buffer where you can type your prompts and submit them by =C-c RET=. If you have access to *GPT 4.0*, you can set that up by setting =gptel-model=. You can also use =org-mode= instead of =markdown-mode= by setting =gptel-default-mode= but *be aware that this converts the response to org-mode by simple regex replacement and often creates mistakes and bugs*. For example, I have noticed random *=* signs in elisp codes because the conversion replaces *`* with *=* to convert inline code from markdown to org-mode, and sometimes it makes a mistake and does that inside a code block.

Here is an example code for installing gptel using =use-package=:

#+begin_src emacs-lisp
(use-package gptel
   :config
   (setq gptel-api-key (auth-source-pick-first-password :host "openai.com"))
   (setq gptel-default-mode 'org-mode)
   (setq gptel-model "gpt-3.5-turbo")
   )
#+end_src

Note that I am using auth-source to store my OpenAI's API key so I don't need to put it in my config. Refer to [[https://github.com/karthink/gptel#usage][gptel documents]] for more info on authentication.

**** Creating a Custom Function to Call gptel

Now that we have gptel installed and running, you can go ahead and create an interactive command to call gptel. We can then use this command to call =gptel= from outside Emacs with emacsclient. Here is a sample function that creates a new frame and runs gptel.

#+begin_src emacs-lisp
(defun ad/ai-from-anywhere ()
(interactive)
(let* ((screen-width (display-pixel-width))
       (screen-height (display-pixel-height))
       (frame-width (/ screen-width 3))
       (frame-height screen-height)
       (frame-left (- screen-width frame-width))
       (frame-top 0)
       (chat-frame (make-frame `((window-system . ns)  ;;change this if you are not on macOS. For example you can use "x" instead of "ns" for x systems. Refer to make-frame documentation for more details
                            (top . ,frame-top)
                            (left . ,frame-left)
                            (width . (text-pixels . ,frame-width))
                            (heigth . (text-pixels . ,frame-height))
                            (minibuffer . t)
                            ))))
  (select-frame chat-frame)
  )
  (add-hook 'gptel-post-response-hook (lambda () (goto-char (point-max))))
  (gptel "My:AI Chat" gptel-api-key nil)
  (switch-to-buffer "My:AI Chat")
  (delete-other-windows)
)
#+end_src
Note how I set the window-system to =ns= (this is for macOS or Linux) and set the frame size and position in pixels by changing =width=, =height=, =top=, =left=, etc. when calling =make-frame=. Refer to Emacs help on =make-frame= or the manual on [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Parameters.html#Frame-Parameters][Frame Parameters]].

**** Setup your Emacs Server

From inside Emacs, you CNA simply run =server-start= to start an Emacs server, and then you can run =emacsclient= from terminal. If you want to run the server as *daemon* in the background, look at [[https://www.emacswiki.org/emacs/EmacsAsDaemon][EmacsWiki: Emacs As Daemon]]. If you are on macOS, this [[https://briansunter.com/blog/emacs-daemon-macos][link]] can provide some more details in addition to EmacsWiki article.

**** Create a script to call Emacsclient

Once you have the server set up and running, you can call emacsclient and run your interactive command to create a new frame and start gptel.

***** macOS

 On macOS, you can do this by writing an apple script and call it from spotlight search similar to this article for org-capture: [[https://macowners.club/posts/org-capture-from-everywhere-macos/][Org capture from everywhere in macOS | macOS & (open-source) Software]]. Simply, open *Script Editor* and make a new *Application* with content similar to the following code. Make sure you adjust the path to your emacsclient and also the name of the interactive command you are calling. Note how I use =select-frame-set-input-focus= to make sure the window is focused.

 #+begin_src apples
on run
    try
        do shell script "/opt/homebrew/bin/emacsclient -e \"(progn (select-frame-set-input-focus (selected-frame)) (ad/ai-from-anywhere))\"> /dev/null 2>&1 &"
    if application "Emacs" is running then
        tell application "Emacs" to activate
    end if
    end try
end run
 #+end_src

Save the file as *Application* in your default applications folder and name it something easy to remember like =myai=.

Then call the spotlight search (bound to =⌘ SPC= by default) and search for your new application (e.g. =myai=). When you run it, it should create a new Emacs frame, and you can start chatting with GPT right away.

***** KDE Plasma

You can do something similar in KDE Plasma. You can create a custom shell script with the following content:
#+begin_src shell
#!/bin/bash
emacsclient -e \"(progn (select-frame-set-input-focus (selected-frame)) (ad/ai-from-anywhere))\"
#+end_src

Save the script in a convenient location such as =~/.local/bin/myai= and make sure to make it executable by using =chmod u+x ~/.local/bin/myai= . Then call the =KDERunner= (bound to =Alt SPC= by default) and search for your shell script.

***** Other Systems

I have not tried this on other systems, but you can similarly make shell scripts to call emacsclient and run similar searches on most systems (windows button on Windows, unity search on, etc.) and you will have a ChatGPT app.


**** Screenshot

That's it. Now go get a cup of coffee and start a conversation with our future overlords. Make sure you are nice to them!

Here is a screen shot of my ChatGPT app on macOS:

#+ATTR_ORG: :width 800px :height nilpx
#+ATTR_LATEX: :width 800px :height nilpx
#+ATTR_HTML: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Use_Emacs_as_a_chatgpt_client/Screenshot.gif]]







*** DRAFT Why scientists need a website?            :@software:@scientists:web:
:PROPERTIES:
 :EXPORT_HUGO_DRAFT: true
 :EXPORT_HUGO_SECTION_FRAG: why_scientists_need_a_web
 :EXPORT_FILE_NAME: index
 :TITLE: Why Scientists Need a Website
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle
 :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'caption'
  focal_point: 'center'
#+end_src


*** POST Making a modern dashboard for Emacs in 2023
:PROPERTIES:
:EXPORT_HUGO_DRAFT: true
:EXPORT_HUGO_SECTION_FRAG: Making_a_modern_dashboard_for_Emacs_in_2023
:EXPORT_FILE_NAME: index
:TITLE:    Making a modern dashboard for Emacs in 2023
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle A Tutorial on How  to Create a Modern, Functional Dashboard to Orgzanize your Workfows in Vanilla Emacs
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post I share the config for my Emacs' dashboard after many people have requested it since my previous posts.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
categories: [software, emacs, dashboard]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
gallery_item:
- album: emacs-dashboard-logos
  image: armindarvish-bird.png
  caption: A bird logo for your emacs dashboard. Good for both dark and light themes.
- album: emacs-dashboard-logos
  image: armindarvish-eagle.png
  caption: An eagle logo for your emacs dashboard. Good for dark themes only.
- album: emacs-dashboard-logos
  image: armindarvish-elogo1.png
  caption: A modern logo for your emacs dashboard. Good for light themes only.
- album: emacs-dashboard-logos
  image: armindarvish-elogo2.png
  caption: A modern logo for your emacs dashboard. Good for light themes only.
- album: emacs-dashboard-logos
  image: armindarvish-elogo3.png
  caption: A modern logo for your emacs dashboard. Good for both dark and light themes.
- album: emacs-dashboard-logos
  image: armindarvish-elogo4.png
  caption: A modern logo for your emacs dashboard. Better for light themes.
- album: emacs-dashboard-logos
  image: armindarvish-elogo5.png
  caption: A modern logo for your emacs dashboard. Good for both dark and light themes.
- album: emacs-dashboard-logos
  image: armindarvish-gnu1.png
  caption: A gnu logo for your emacs dashboard. Good for both dark and light themes.
- album: emacs-dashboard-logos
  image: armindarvish-gnu2.png
  caption: A gnu logo for your emacs dashboard. Good for both dark and light themes.
- album: emacs-dashboard-logos
  image: armindarvish-gnu3.png
  caption: A gnu logo for your emacs dashboard. Good for dark themes only.
- album: emacs-dashboard-logos
  image: armindarvish-lion.png
  caption: A lion logo for your emacs dashboard. Better for dark themes.
- album: emacs-dashboard-logos
  image: armindarvish-octopus.png
  caption: An octopus logo for your emacs dashboard. Good for both dark and light themes.
#+end_src

Ever since I shared some of my emacs workflows and packages on this blog, I have been getting requests for my Dashboard config, and in this post I am finally going to write about it. Now, I should warn you that I am not going to share a config you can copy paste in your init file and use as is. If you are looking for one of those there are enough blog posts, youtube videos, GitHub gists, etc by people who are much better than me at creating such content. What I like to write about in this blog is integrating different tools into a practical and efficient workflow. What does that mean? It means that instead of showing how to configure one package, I tend to focus on how to combine different packages into a workflow. For example in my post about using emacs as a blog editor, [[https://www.armindarvish.com/en/post/building_an_efficient_blogging_workflow_in_emacs/][Building the Best Blog Editor with Emacs Org-Mode in 2023?]], I wrote about how to combine =org-todo= keywords with =ox-hugo= and some other tools like =org-capture= templates and =yasnippet= , ... to create a fully functional and efficient blog editor inside emacs. In this post I am going to try to do something similar with the Dashbaord! I am going to show you how you can integrate the Dashboard as part of your custom workflow. In the process of showing you how to make a more modern dashboard personalized to your own taste, I will also share some tips for.
for better look and feels if that's what you are looking for.

**** Before Getting Started
***** Ask yourself why you should make a dashboard and is it worth the time?

Before we start talking about creating a dashboard, take a step back and ask yourself if this is useful to you? and how would it improve your day-to-day workflow. Personally, the Dashboard is a great tool for me to see an overview/summary of what I am currently working on (different projects, blog posts, ...) and choose the next task. It helps me stay focused on the tasks that are of priority and organize my workflow around them. I can of course use an org file with tasks in it to organize everything I do, but whenever I tried something like that it grew and became very messy quickly and then it required too much overhead to maintain and eventually was abandoned. The dashboard, on the other hand keeps things simple and clean and cannot be too crowded and as a result helps me focus on what matters the most. I still use org-files for keeping all the details but I don't have to worry about maintaining them and keeping them clean as much anymore. In other words, a good dashboard keeps all the noise out of my immediate view and directs me to all the important signal. This has helped me stay away from the "never-ending spiral of tinkering with Emacs configs". I start my emacs in my dashboard and right away I can see the tasks/projects/... I am working on and instead of wandering to other distracting ideas, I will directly jump to important items I have to work on. Over time, I have made a habit of always returning to the dashboard, and look at the overview again before picking the next item and as a result I stay focused on getting things done.


Now, if you look at other dashboards like the default dashboard in doom emacs or spacemacs, you may be thinking that this is pointless. After all, you can simply open any of those links in the dashboard by opening a new buffer anytime needed from any buffer and can quickly switch between them between them (e.g. by =C-x b=) as well. If you use a package like [[https://github.com/minad/consult][consult]], you can even further customize buffer switching and see items such as your recent files, ... when switching buffers. So what is the purpose of the dashboard then? Is it just a fancy-looking starting buffer to replace scratch-buffer? The answer depends of course on how you use Emacs. Personally I tend to open a lot of buffers, just like I do with browser tabs, and while I can do =M-x consult-buffer= and search through them to find the ones I am looking for, it does not provide an overview/summary like my dashboard (items in my agenda, projects I am working on, etc.). In other words, if have a Dashboard that simply contains a bunch of static shortcuts to some files or buffers (like the default dashboard in doom emacs), then there is not much of a use to it. You can directly jump to those files/buffers without going to dashboard first. But, if you make a custom dashboard that is more dynamic and organizes tasks, projects, and etc. for you and gives you a high-level overview of the most important items, then it becomes much more useful and you will likely find yourself going back to it.

The other question you may want to ask yourself is: "Is it worth it to spend time to make a custom dashboard? It is after all yet another tinkering task that keeps you from doing actual work!". In general, this is a question a lot of people struggle with when it comes to configuring Emacs. If you are one of those who constantly find yourself in this trap of tinkering with Emacs config instead of doing actual work, then remember this is not so much of an "Emacs problem" but more of  a "YOU problem". You need to change the way you approach using Emacs and building your config, etc. I don't intend to blame you for anything. A lot of emacs users at some point or another fall into this trap and go down the rabbit hole of configuring hundreds of packages only to realize that they don't use 90% of them. I certainly have gone down that rabbit hole before and quite ironically the answer is well some Emacs package 😆 (including the Dashboard I show you in this post).Here is generally what as helped me to focus on getting things done rather than constantly changing my Emacs config. Instead of focusing on configuring a single package based on some shiny videos I just watched online, I focus on building workflows for current projects I am working on. I break work packages into smaller meaningful blocks of simple tasks. Then I find the right packages that fits my workflow and start testing them out with the *bare minimum configuration* until I hit a bottleneck and see the need to change things. Then, with the knowledge of the specific issues I need to solve (rather than imaginary nice-to-have wishes), I spend some time doing research, looking at other people's approaches and optimizing my own config. Through multiple such iterations I arrive at a highly personalized workflow that serves every need I have without spending a lot of time on extra configurations I will never need and it all happens as part of getting other works done and not instead of them.

That is, of course, not to say that I don't randomly explore packages and configs. I definitely do that every now and then to see new tools and approaches that may give me ideas for how to improve my workflow. Sometimes wandering around without any destination or directions in mind is the best way to find the most amazing least-explored destinations after all, but do that too often you will ensure you get lost! There is a balance to keep and trade-offs to make when building your own tools. My suggestion is to always start with the minimal working prototype and refine everything from there as the needs arise. Contrary to the popular beliefs, great products and tools are often the result of many years of evolution and not execution of a well-engineered genius plan! What I am about to show you here is the result of refining my own dashboard over several years, and it will likely go through many more iterations as my projects, workflows and etc. evolve over time. In fact a great advantage of building your own tools in Emacs is exactly the this point that they can evolve with you and transform with your project and your needs rather than by some popular trend or the latest fad around the corner.

***** Plan your Dashboard, or the first iteration of it anyway

A dashboard is by nature a personalized/customized tool. It is supposed to present the *most important* information for the context in the *most efficient and concise* form. In a car, the dashboard shows you what is the most important indicators to watch for the task at hand, driving. In Emacs, however, the most important indicators depend on what it is that you are currently doing in Emacs. Before you build your dashboard, then, you need to review how you use Emacs and decide what is the context (use-cases, frequency, importance, ...) and choose the most important information/indicators that you want to see on your dashboard. The good thing about doing things in Emacs is that not only everything is customizable, but they are also dynamic. Your Dashboard can change based on time of the day, or your recent activities, or based on the context of what you're doing in other buffers, etc.

Start by thinking through your workflow and organize what you do in Emacs into meaningful blocks or categories, and then ask yourself what your dashboard should contain for each of these and how should it present it to you. To me, a dashboard is part of a ="system of doing things"=. It focuses on tasks and projects, and organizes them in order of priorities for me. But, to you it might mean something else. May be you want to use it to see "a list of books" you are reading or you want to see "pictures of destinations" you want to visit or may be you want to keep "a list of values" you want to remember or "description of ideas/concepts" you want to think about, ...

One more thing to understand before we start coding is that an Emacs dashboard is by nature only a transient state. It is often just a starting page that you may return to temporarily to see an overview of everything before you jump to the next item. So, at the end of the day, you will only spend a limited amount of time looking at this dashboard, and therefore it should be concise and clear and easy to navigate otherwise it won't be as useful.

***** Setting up Emacs
****** Setting  packages

In my own emacs config, I use [[https://github.com/radian-software/straight.el][straight.el]] and use a literate config file in org-mode. But for the sake of simplicity and keeping this post beginner-friendly, I am going to show you a minimal approach with built-in =package.el= and =use-package=. If you are an advanced user, and just want to see the dashboard config, jump ahead and look at the dashboard section. You should be able to copy the config for the dashboard package and adapt it with any package manager you use. If you are a beginner, I recommend starting with something simple to learn the basics before switching to more advanced package managements and configuration. The [[https://www.youtube.com/playlist?list=PLEoMzSkcN8oNmd98m_6FoaJseUsa6QGm2][Emacs From Scratch Series]] by David Wilson is probably a good place to start.

Here is a minimal setup for package management using =use-package=:

#+begin_src emacs-lisp
(require 'package)

;; Adds the Melpa archive to the list of available repositories
(setq package-archives
      '(("elpa" . "https://elpa.gnu.org/packages/")
        ("melpa-stable" . "https://stable.melpa.org/packages/")
        ("melpa" . "https://melpa.org/packages/")
        ("org" . "https://orgmode.org/elpa/"))
      )

;; Initializes the package infrastructure
(package-initialize)
(package-refresh-contents)
(package-install 'use-package) ;;no need to install use-package in Emacs >29 since it is built-in
(setq use-package-always-ensure t)
#+end_src


****** General Layout, Font and Theme

First things first, consider picking a layout, theme, font, etc. and find some settings you are going to stick with for a while. A dashboard is a place where you prioritize important information, topics, projects, tasks , ... and that often requires ui elements to present information in a concise format. For example using icons, or color-coding can help create patterns which helps building habits (e.g. focus on important info in red color, start with checking items with important icon, etc.) and that leads to an organized efficient workflows over time. Therefore, it is important to decide on the general appearance of your Emacs and find ui elements you like before you spend too much time on your dashboard's looks and feel.

******* Layout

Start with different settings for toolbars and menus to find what is most appealing to you. Most advanced users would suggest turning all the toolbars off, since in Emacs you would mostly be using keyboards anyway, but at the beginning you may want to experiment with it and find out what works for you. There are also other universally recommended settings, like turning the bells off!

#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode 1)
(scroll-bar-mode -1)
(setq inhibit-startup-screen t)
(setq visible-bell nil)
#+end_src

******* Theme and Font

A quick and simple starting point can be [[https://github.com/protesilaos/modus-themes][modus-themes]] that comes built-in with newer versions of Emacs. I personally like dark-themes better because they allow me to focus better and therefore would recommend =modus-vivendi= or one of the other dark alternatives. But if you like light themes, =modus-operandi= is also great. If those do not look appealing to you, you can try [[https://github.com/protesilaos/ef-themes][ef-themes]] by the same author. You can always customize the theme later, so as long as it generally looks good, that should serve fine as a starting point. For fonts, [[https://fonts.google.com/specimen/Fira+Code][Fira Code]] or [[https://fonts.google.com/specimen/Roboto+Mono][Roboto Mono]] can be a good starting point.

#+begin_src emacs-lisp
(load-theme 'modus-vivendi-tinted)
(set-face-attribute 'default nil :font "Roboto Mono" :height 190)
#+end_src

In addition, having icons is useful especially if you later want to use icons in your dashboard as well. [[https://github.com/domtronn/all-the-icons.el][all-the-icons.el]] has historically been a favorite icon package, but more recently [[https://github.com/rainstormstudio/nerd-icons.el][nerd-icons.el]] is an alternative that also works in the terminal.

#+begin_src emacs-lisp
(use-package nerd-icons
  :config
  (setq nerd-icons-font-family "Symbols Nerd Font Mono")
  )
#+end_src

******* Modeline

Next, make sure you chose a good modeline. I personally like [[https://github.com/seagle0128/doom-modeline][doom-modeline]], but there are other options for configuring modeline.  You can refer to [[https://www.emacswiki.org/emacs/ModeLineConfiguration][EmacsWiki's Modeline Configuration]] page for some suggestions. If you chose doom-modeline, install nerd-icons first if you want icons. Here is some config suggestion for doom-modeline:

#+begin_src emacs-lisp
(use-package doom-modeline
  :after nerd-icons
  :init
  (doom-modeline-mode 1)
  (setq doom-modeline-support-imenu t)
  :custom
  (doom-modeline-height 10)
  (doom-modeline-bar-width 6)
  (doom-modeline-icon t)
  (doom-modeline-major-mode-icon t)
  (doom-modeline-major-mode-color-icon t)
  (doom-modeline-minor-modes nil)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-modal-icon t)
  (doom-modeline-enable-word-count nil)
)
#+end_src


****** Consider installing some other packages

Consider using other packages depending on your needs. There are a handful of packages that can be considered essential. These are the ones that will improve your emacs experience including setting up your configuration:

1. Completion Framework: At some point you would need a completion package. The set of packages: [[https://github.com/minad/vertico][vertico]], [[https://github.com/minad/consult][consult]], [[https://github.com/minad/marginalia][marginalia]], [[https://github.com/minad/orderless][orderless]], and [[https://github.com/oantolin/embark][embark]] are great for completion. [[https://github.com/abo-abo/swiper][ivy]] and [[https://github.com/emacs-helm/helm][helm]] are other popular alternatives.

2. Key-binding Setting and Menu: [[https://github.com/noctuid/general.el][general.el]] is a great package that simplifies your keybindingf config. [[https://github.com/justbur/emacs-which-key][which-key]] provides useful visual menus if you want reminders of keybindings.

3. Evil-mode: [[https://github.com/emacs-evil/evil][evil]] is great if you like vim keybindings.

Importantly, you should think about packages/settings that allow creating better items in your dashboard.

**** Making a Modern Dashboard

Finally we are ready to dive into building a Dashboard. If you are new to Emacs, I recommend you use emacs for a few weeks or months and experiment with your settings for appearance, keybindings, etc. before thinking about building a dashboard.

For the purpose of this post, I am going to use the fabulous [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] package as it provides a bunch of useful elements right out of the box. you can install it by:

#+begin_src emacs-lisp
(use-package dashboard
  :demand t
  :hook
  (dashboard-mode . visual-line-mode)
  :config
  (dashboard-setup-startup-hook)
  (dashboard-open)
  )
#+end_src

Out of the box, the Dashboard package provides several general segments but you will likely need to customize it significantly if you want more than just a bunch of static links. I my opinion, the default appearance, is also not that great. So in the rest of this post, I'll show you how to customize everything. The official manual on [[https://github.com/emacs-dashboard/emacs-dashboard][emacs-dashboard]] contains everything you need to know about the mechanics of customizing the dashboard, but here I am going to try to put things in context and focus on ideas for how to make more dynamic elements and more modern looks, etc.


***** Basic Configuration of the Dashboard

Here is an overview of the sections, faces, etc. for reference. The labels that are underscored are the name of =faces= and the rest are the name of variables.

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/content/en/post/Making_a_modern_dashboard_for_Emacs_in_2023/emacs dashboard overview.png]]

Note that when you load the dashboard by default some of these sections like the navigator buttons may not be there, but after you configure your dashboard this is pretty much everything you can have, and everything here is customizable.

****** Changing Colors and Faces

You can change the color of the banner or the text by changing the relevant faces (see the picture above). In the code below I am changing the faces for =dashboard-banner-logo-title= and the =dashboard-text-banner=.
#+begin_src emacs-lisp
 (set-face-attribute 'dashboard-banner-logo-title
                      nil
                      :foreground "#FF0BAF"
                      :weight 'bold)

(set-face-attribute 'dashboard-text-banner
                      nil
                      :height 1.5
                      :weight 'bold
                      :inherit 'warning)


#+end_src
One good way of configuring faces, is to use =:inherit= property and link the faces to other faces that most themes customize like =font-lock= faces. That way, if you switch themes, your dashboard looks changes accordingly. Personally I have my own customized theme and almost never switch to another theme, therefore I directly set the faces to what matches my default theme.

****** Set the Logo

The logo is one of the main features of my own dashboard. I like to have some pictures that blends nicely with the background to make the look appealing to me. This comes at the cost of some real state, so I can see fewer items in my dashboard without scrolling, but I like my dashboard to look nice and inspiring so that every time I open the dashboard it gives me a refreshing energetic feeling for the next task otherwise if it is just a boring list of things to do, I will not be so willing to go back to it. Going back to my dashboard is also a short break time, so I like to have contents that make it a little bit more fun and take my attention away from just getting things done for a brief moment.

For the logo, I usually use some artsy AI-generated colorful photo that I make on [[https://www.midjourney.com/][Midjourney]]. If you like to make your own photos, here are some tips:
1. Use some color schemes that go well with your theme. For example for dark themes (e.g. modus-vivendi), I like to use neon colors.
2. I usually use a 3:2 aspect ratio and center the image. On most screens this looks very good. If you want a full-width banner instead, then you can make an image of the exact width of your screen and use that.
3. Use an image with a transparent background (or start with a solid background and remove the background in a photo-editing app) so it naturally blends in with the background of your emacs.

Here is an example of what I made on [[https://www.midjourney.com/home/?callbackUrl=%2Fapp%2F][Midjourney]] with a simple prompt like this:
#+begin_src text
abstract lion logo with dark background, pink blue and orange colors, particles --ar 3:2
#+end_src

#+attr_org: :width nilpx :height 300px
#+attr_latex: :width nilpx :height 300px
#+attr_html: :width nilpx :height 300px
[[file:~/projects/armindarvish-website/content/en/post/Making_a_modern_dashboard_for_Emacs_in_2023/armindarvish-lion.png]]


I have removed the dark background in photoshop. Note how the particle/flame effect makes this blend in with the background and gives the logo some depth.


For a light theme (or in general for something that looks good on both dark and light theme), it might be better to start with a picture with white background and then remove the background. Here is another Midjourney example for a modern emacs logo with *a gnu and the letter e*:
#+begin_src text
modern minimalist logo for a text editor app called "emacs", purple ink bubble, letter E, shape of a gnu head, geometric, neon colors, futuristic, white background, modern software logo, --ar 3:2
#+end_src

#+attr_org: :width nilpx :height 300px
#+attr_latex: :width nilpx :height 300px
#+attr_html: :width nilpx :height 300px
[[file:~/projects/armindarvish-website/content/en/post/Making_a_modern_dashboard_for_Emacs_in_2023/armindarvish-gnu.png]]


and, here is a full album with more examples for you to get inspiration from:

#+begin_export hugo
{{< gallery album="emacs-dashboard-logos" resize_options="300x200" >}}
#+end_export

Download one of the photos you like and set the =dashboard-startup-banner=:
#+begin_src emacs-lisp
(setq dashboard-startup-banner (expand-file-name "path-to-the-image-file" user-emacs-directory)
#+end_src

****** Set Sections

Let's see how we can toggle certain sections on/off. Generally we will be using the variables =dawshboard-set-*= to turn sections on/off. Here is a script that turns all the sections on.

#+begin_src emacs-lisp
(setq dashboard-set-heading-icons t)
(setq dashboard-set-file-icons t)
(setq dashboard-set-footer t)
(setq dashboard-set-init-info t)
(setq dashboard-set-navigator t)
(setq dashboard-week-agenda t)
#+end_src

Note that these are different from =dashboard-*= variables. The former variables are for toggling hide/show whereas the later ones contain the contents or change the style of the text. For example =dashboard-set-footer= is to show/hide the footer whereas the variable =dashboard-footer= contains the string of the current footer. In addition there are some extra variables to further customize the contents. You can read about customizing these variables in the official documents, [[https://github.com/emacs-dashboard/emacs-dashboard][here]]. Just to show you some examples, in the code below I set the variable =dashboard-center-content= to make the text centered and also change the =dashboard-item-names= to change the default title of the =agenda= section:

#+begin_src emacs-lisp
(setq dashboard-center-content t)
(setq dashboard-item-names '(("Agenda for the coming week:" . "Agenda:")))
#+end_src

****** Set the text below the log

For the text below the logo, instead of using some fixed text, I like to use something more dynamic. For example, I like to have random inspiring quotes on my dashboard. When I am transitioning from one task to the next, I jump to my dashboard and take a break to read the quote and reflect on it, then I pick up the work for the next task. For  getting quotes, I use the package [[https://github.com/mubaris/motivate][motivate]]. It is a python-based package that gets motivational quotes in the command line. Follow the official instructions to install it. Then you can use =shell-command-to-string= to call it and get a quote as a string. You may then have to do some clean up with =replace-regexp-in-string=. Here is a snippet that gets the quote and cleans it up:

#+begin_src emacs-lisp :results raw drawer
(defun ad/get-motivational-quote ()
(let ((quote (replace-regexp-in-string "\^[.*?m" "" (shell-command-to-string "motivate"))))
(string-match "\"\\(?1:.*\\).*\".*\n.*--\\(?2:.*\\)\n" quote)
(concat "\"" (match-string 1 quote) "\"" "\n\t\t\t\t\t\t'" (match-string 2 quote) "'")))
#+end_src

Then you can set the text below the logo like this:
#+begin_src emacs-lisp
(setq dashboard-banner-logo-title (ad/get-motivational-quote))
#+end_src

****** The navigator

The navigator is one of the most useful parts in my personal dashboard. I put shortcuts to things that I would like to jump to (e.g. my emacs config, projects, github repos, ...) I like to have a bunch of navigator buttons (some with icons and texts and others with just icons).
The snippet below uses =nerd-icons= and some other packages like my own [[http://localhost:1313/en/post/consult-gh_working_with_github_inside_emacs_in_2023_/][consult-gh]] to access github projects, [[https://github.com/djcb/mu][mu4e]] to open emails, [[https://github.com/skeeto/elfeed][elfeed]] to read feeds, etc. You can make buttons and run any elisp function that you like.

#+begin_src emacs-lisp
    (setq dashboard-navigator-buttons
        `((;; Line 1

              ;;;;Emacs Config
           (,(nerd-icons-faicon "nf-fa-gear" :height 0.8 :v-adjust 0.0)
            "Settings"
            "Configure Emacs"
            (lambda (&rest _) (find-file
                               (expand-file-name "init.el" user-emacs-directory))) dashboard-heading "" "")
              ;;;;Github
           (,(nerd-icons-octicon "nf-oct-mark_github" :height 0.8 :v-adjust 0.0)
            "Github"
            "Open Github in Browser"
            (lambda (&rest _) (consult-gh-default-repos)) dashboard-heading "" "")

              ;;;;projects
           (,(nerd-icons-mdicon "nf-md-rocket_launch" :height 0.8 :v-adjust 0.0)
            "Projects"
            "Open my projects"
            (lambda (&rest _) (consult-projectile-switch-project)) dashboard-heading "" "")
           )

          (;; line 2
               ;;;;empty space
           ("\t\t\t\t\t\t\t\t\t\t\t\t\t" "" "" nil nil "" "")

               ;;;;emails
           (,(nerd-icons-mdicon "nf-md-email" :height 1 :v-adjust 0.0)
            ""
            "Check Emails"
            (lambda (&rest _) (mu4e)) dashboard-heading "" "")

               ;;;;rss
           (,(nerd-icons-mdicon "nf-md-rss_box" :height 1 :v-adjust 0.0)
            ""
            "Check Feed"
            (lambda (&rest _) (elfeed)) dashboard-heading "" "")

               ;;;;calendar
           (,(nerd-icons-mdicon "nf-md-calendar" :height 1 :v-adjust 0.0)
            ""
            "Calendar"
            (lambda (&rest _) (cfw:open-calendar-buffer)) dashboard-heading "" "")

               ;;;;help
           (,(nerd-icons-mdicon "nf-md-help_rhombus" :height 1 :v-adjust 0.0) "" "?/h" (help) dashboard-heading "" "")
           )))
#+end_src




#+begin_src emacs-lisp
(insert (battery-format "%b%p%% %t hours" (funcall battery-status-function)))
(insert (concat (car doom-modeline--battery-status) (cdr doom-modeline--battery-status)))
#+end_src

#+begin_src emacs-lisp
  (defvar my:motivate-quote (format "%s"
                                    (replace-regexp-in-string "\t" " " ;;replace "\"
                                                              (replace-regexp-in-string "/\\/" "" ;;replace "\" with newline
                                                                                        (replace-regexp-in-string  "\n" "" ; remove all newlines
                                                                                                                   (replace-regexp-in-string "\^[.*?m" ""  ;remove extra garbage
                                                                                                                                             (shell-command-to-string "motivate")))))))


  ;; (setq dashboard-init-info my:motivate-quote)
  (setq dashboard-banner-logo-title my:motivate-quote)
#+end_src
#+begin_src emacs-lisp
(use-package dashboard
  :init
  (dashboard-setup-startup-hook)
  (get-buffer-create "*dashboard*")
)
#+end_src

#+begin_src emacs-lisp
(use-package dashboard
  :init
  (dashboard-setup-startup-hook)
  (get-buffer-create "*dashboard*")
  :hook
  (dashboard-mode . visual-line-mode)
  :general
  (:keymaps 'dashboard-mode-map
            :states '(normal insert motion visual emacs replace operator)
            "<f5>" 'dashboard-refresh-buffer
            "f" 'find-file
            "m" '(lambda () (interactive) (mu4e-search-bookmark "maildir:/gmail/armindarvish/Inbox/"))
            "c" 'my:calendar
            "e" 'elfeed
            "SPC" '(:ignore t :which-key "jump")
            "SPC t"  '((lambda () (interactive) (find-file (file-truename (expand-file-name "Notes.org" my:mainorgfolder)))
                    (my:org-narrow-to-header " Tasks")) :which-key "Tasks")
            "SPC n"  '((lambda () (interactive) (find-file (file-truename (expand-file-name "Notes.org" my:mainorgfolder)))
                    (my:org-narrow-to-header " Notes")) :which-key "Notes")
            "SPC b"  '(my:consult-blog :which-key "My Blog Posts")
            )
  :config
  (setq dashboard-projects-backend 'projectile)
  )

#+end_src
if you keep changing the looks every week. What you want to achieve is to create patterns (with colors, icons, etc.) that inspire habits over time

the tools to serve these workflows. Now, some people would argue that this is a total waste of time or an unnecessary rabbit hole to customize your tools or workflows. After all you can find some tools that just works out of the box! But  because

Before I show you how I build a dashboard, This  may seem unrelated, since dashboards and themes are independent, in my opinion the key to having a good dashboard is to first chose the right theme. I, personally build workflows in emacs and as a result every piece of the config becomes and integral to a bigger system of "how I do things". The theme, font, colors, etc. are a very useful way of creating patterns and patterns turn into habits over time. A dashboard that does not reinforce such habits would not stick around for long because more efficient workflows and ways of doing things will emerge.

****** main items

****** footer

***** Making everything more dynamic

Now that we covered the basic config of the dashboard, let's take things to the next level and make everything more dynamic. To do this, I am going to implement multiple concepts:

1. Use Functions to Define Multiple Dashboards:
Working inside emacs, means that we can create funcitons that set the dashboard configuration and bind different keybindings to them. Then we can load any of the dashboards depending on the need. For example you can have =Main= dashboard for project overviews (timeline, priorities, etc.) and a =Dev= dashboard for technical stuff like codes you are working on, and a =Fun= one for ideas you are considering for your next vacation!

2. Define Contexts:
A great way of customizing Emacs, that allows you to create super-focused work flows is to introduce contexts. For example you can define variable that changes based on time of the day. Then you configure your Emacs to load a dashboard related to work during work hours, and another one for your personal projects in the after hours, or may be you want to separate technical projects (e.g. coding, engineering, ...) from creative projects (making videos, writing blogs,...) or may be you want to define context base don the technology you are using (one for you Mac laptop and another for your Linux server). Having variables in Emacs that track such context is extremely useful for building configs that adapt to your every need.


By combining 1 and 2 above, you can essentially build dynamic dashboards in any imaginable way you wish to.

****** A function to define the main dashboard.

Let's pull together what we learned in the previous section and put it in one function to load our main dashboard that shows work related projects:

#+begin_src emacs-lisp
(defun ad/get-motivational-quote ()
(let ((quote (replace-regexp-in-string "\^[.*?m" "" (shell-command-to-string "motivate"))))
(string-match "\"\\(?1:.*\\).*\".*\n.*--\\(?2:.*\\)\n" quote)
(concat "\"" (match-string 1 quote) "\"" "\n\t\t\t\t\t\t'" (match-string 2 quote) "'")))

(defun ad/main-dashboard ()
(interactive)
;;custom faces
 (set-face-attribute 'dashboard-banner-logo-title
                      nil
                      :foreground "#FF0BAF"
                      :weight 'bold)
  (set-face-attribute 'dashboard-text-banner
                      nil
                      :height 1.5
                      :weight 'bold
                      :inherit 'warning)
;;
  (setq dashboard-center-content t
        dashboard-set-heading-icons t
        dashboard-set-file-icons t
        dashboard-set-footer t
        dashboard-set-init-info t
        dashboard-set-navigator t
        dashboard-item-names '(("Agenda for the coming week:" . "Agenda:"))
        dashboard-week-agenda
        dashboard-banner-logo-title (ad/get-motivational-quote)
        )
#+end_src

****** Let's now make a variable to define context and use it to change the dashboard according to the time of the day


*** PUBLISH Announcing Consult-GH 2.0
CLOSED: [2023-10-09 Mon 23:55]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: announcing_consult_gh_2
:EXPORT_FILE_NAME: index
:TITLE:    Announcing Consult-GH 2.0
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle now using async commands by utilizing consult-async
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post I am announcing a major update to consult-gh and will showcase some of the main improvements.
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
categories: []
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src

If you follow my posts, you probably have seen my previous post [[https://www.armindarvish.com/en/post/consult-gh_working_with_github_inside_emacs_in_2023_/][introducing consult-gh]]. Since I wrote that post, there were requests for some features (e.g. integration with [[https://github.com/magit/forge][magit/forge]]) that are all now implemented, and while I was working on that I started playing around with consult's [[https://github.com/minad/consult#asynchronous-search][async search feature]] and realized that this indeed enables a much more powerful interface for consult-gh. Therefore, I redesigned the whole package and reimplemented most functions from scratch. The results is now merged on the main branch of [[https://github.com/armindarvish/consult-gh][consult-gh]], and in this post I am going to show you some of the main improvements.

**** async search

As noted on the comments on [[https://www.reddit.com/r/emacsporn/comments/14p42xq/comment/jqii09k/?context=3][this reddit post]], the previous interface for searching was subpar. It required the user to enter a search term, hit return and then see the results. If the results was not what the user wanted, he had to rerun the M-x command  or key-binding and start form scratch. If the user made a typo, he would see a message saying no results were found without knowing that a typo was made. Using consult-async solves all of that. It dynamically updates the completion table as the user is typing.
The screenshot below shows the async search and dynamic updates in action:

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/tmp/code/consult-gh/screenshots/consult-gh-search-repos.gif]]
**** passing command line arguments

Another advantage of using consult-async machienry is that the user can also pass other command-line arguments from within the emacs minibuffer. In case of consult-gh, this would allow the user to adjust the queries on the fly. For example the user can simply pass a command-line argument by adding =-- --limit {number}= to the minibuffer to change the maximum number of results fetched.

Note that the variables for setting limits (such as =consult-gh-repo-maxnum= and =consult-gh-issue-maxnum=) are still available to set the values globally but, per individual commands, the user can change the limit dynamically when needed. Other command line arguments (such as sort, ...) can also be passed similarly in the minibuffer. This also allows using the whole machinery of =gh=, especially [[https://docs.github.com/en/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax][gh's search syntax]] to further filter the results.
For example, the screenshot below shows how to search issues and then use the extra command line arguments to filter issues to only show the ones assigned to yourself:

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/tmp/code/consult-gh/screenshots/consult-gh-search-issues.gif]]

**** searching codes

In addition, consult-gh now allows searching codes from emacs minibuffer. This is far superior to using =gh= command line tool because not only it allows to preview/open the file containing the code, but also jumps to the code snippet in the file. Here is a screenshot of searching code in action:

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/tmp/code/consult-gh/screenshots/consult-gh-search-code.gif]]


**** Integration with magit/forge

Consult-gh now supports integration with [[https://github.com/magit/forge][magit/forge]] for viewing/editing issues and pull requests as well. This can simplym be done by loading =consult-gh-forge= and setting the actions for issues and pull requests accordingly. Here is a minimal configuration setting using [[https://github.com/radian-software/straight.el][straight.el]]:

#+begin_src emacs-lisp
(use-package consult-gh
  :straight (consult-gh :type git :host github :repo "armindarvish/consult-gh")
  :after forge
  :config
  (require 'consult-gh-embark)
  (require 'consult-gh-forge)
  (setq consult-gh-preview-key "M-o")
  (setq consult-gh-issue-action #'consult-gh-forge--issue-view-action) ;;this enables opening issues in magit/forge buffer
  (setq consult-gh-pr-action #'consult-gh-forge--pr-view-action) ;;this enables opening pull requests in magit/forge buffer
  (setq consult-gh-forge-timeout-seconds 20) ;;maximum time in seconds for consult-gh to try opening issues/prs in forge, and then reverts back to opening in normal emacs buffers.
)
#+end_src

**** Transient menu

In addition, consult-gh now offers a transient menu to quickly find the relevant commands or change settings. It can be accessed by running =M-x consult-gh= after loading consult-gh-transient module. Just make sure that the transient package is installed before loading consult-gh-transient. Here is a minimal setup script:

#+begin_src emacs-lisp
(use-package consult-gh
  :straight (consult-gh :type git :host github :repo "armindarvish/consult-gh")
  :after forge transient
  :config
  (require 'consult-gh-embark)
  (require 'consult-gh-transient)
)
#+end_src

and here is a screenshot of the transient menu:
#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/tmp/code/consult-gh/screenshots/consult-gh-transient.gif]]

This is still work in progress. I will likely add more features to this transient menu. So give it a try and let me know if you have suggestions in the comments below or on the github repos here: [[https://github.com/armindarvish/consult-gh][consult-gh]].

*** PUBLISH Improve your mu4e workflow with consult-mu
CLOSED: [2024-03-08 Fri 09:48]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: Improve_your_mu4e_workflow_with_consult-mu
:EXPORT_FILE_NAME: index
:TITLE:    Improve your mu4e workflow with consult-mu
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle get dynamically updated search results, fast async search, interactive menus for attachments, and more...
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary In this post I show you my consultmu package that can add some extra features to your mu4e workflow
:END:

#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: [software]
categories: [software, emacs, email client, mu4e]
featured: false
commentable: true
image:
  caption:
  focal_point: 'center'
  #+end_src


**** Introduction
I have been using =mu4e=, as my email client inside emacs for a few years and in my experience it is one of the best clients because it is feature-rich, and yet distraction-free. I think most features that one would expect in a modern email client is already built-in. You can easily set up multiple accounts using =mu4e-contexts=. The search performance is relatively fast and There is built-in saved searches with =mu4e-bookmarks=. The =mu4e-view-mode= provides one of the best reading panes of any client. You can have it side-by-side or in full window and can quickly navigate through your mailbox from within the reading pane by using =mu4e-view-headers-next= and =mu4e-view-headers-prev=. You can quickly organize emails with =mu4e-marks= from either  =mu4e-headers-mode= and =mu4e-view-mode= (a.k.a. reading pane), and being in emacs everything can be done with strokes of a few keys, which makes email management very efficient. However, there are some areas where I think mu4e can use improvements (at least for my work flow, it does) especially for search UI and performance.

Looking at discussion threads online, there are many posts on ="mu4e v.s. x"= package, and often times there are complains about performance with suggestions to switch to another client/package. For example, in recent years, notmuch has become a popular alternative for its performance and ability to handle many thousands of emails. If you are interested to know why I prefer to use mu4e, you can jump ahead and read the part [[id:909D9897-699A-4328-942F-3ABD7417A328][at the end of this post]]. But, I decided making a package, [[https://github.com/armindarvish/consult-mu][consult-mu]], to deal with some of the missing features for my work flow in =mu4e= is a better path than switching entirely to another tool. In this post I am going to summarize some of the important features of =consult-mu= for other people that might be interested and looking for a similar tool. Feel free to explore the tool for yourself and contact me if you have suggestions or feedback.

I should also add that [[https://github.com/armindarvish/consult-mu][consult-mu]] was highly inspired by [[https://github.com/seanfarley/counsel-mu][counsel-mu]] and [[https://github.com/emacsmirror/consult-notmuch][consult-notmuch]], and some other packages like [[https://github.com/doomemacs/doomemacs][doomemacs]]. In a sense, I have tried to combine all the best features I liked in those packages in one place for the specific case of =mu4e= and decided to put it all together in one package that also provides some consistency with my other work flows (for example looking at GitHub repos with [[https://github.com/armindarvish/consult-gh][consult-gh]]). At the end, I am very happy with how this package has transformed my workflow, plus the fact that the performance (at least in my test) is much better than any other tool I have tried.

**** consult-mu
The package consult-mu aims to provide some the missing elements especially with search UI from mu4e. These include:

***** search
mu4e search functionality is great. It allows the user to search in different fields and allows modifying search queries with =mu4e-search-edit= command as well as toggling search properties with =mu4e-search-toggle-property= command. But, the search results are not updated dynamically (which is the default experience in most clients nowadays). In addition, if there are thousands of hits for the query, it can get really sluggish and laggy (though this has now been improved by a lot in the latest version 1.12). In contrast, running the same search in the terminal with the underlying mu server (e.g. =mu find=) is actually very fast. This means that it is possible to use mu4e and get very fast search results if we bypass all the elisp front-end. The problem is bypassing the-front end functionalities can reduce the usability as well so at the end one has to find the right balance. Personally, I ended up choosing a mixed approach with two different interactive commands:

- consult-mu-dynamic
This interactive command allows the user to search emails similar to mu4e-search but the results are dynamically updated in the minibuffer as the search query is being typed. It uses a somewhat hacked version of mu4e-search without taking over buffers and windows like mu4e-search does. More importantly, it allows passing command line arguments to the search therefore all the toggles can be done dynamically within the same search function. For example, if you want to reorder the results by a different field, you can just pass =-z= s an option to the search query and see the results dynamically update.

In terms of performance, this is similar to mu4e-search, and therefore if your search returns thousands of hits, it can be slow because under the hood we are using the same mechanics. In fact, once the user selects a candidate, it opens a =mu4e-header= buffer with all the results similar to running mu4e-search. The advantage however is that the dynamic update provides a nice modern intuitive interface with previews in buffers that stay out of your way if you just want to see an email and go back to whatever you were doing, so it can boost efficiency compared to using mu4e-search.

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/projects/armindarvish-website/static/ox-hugo/consult-mu4.gif]]

- consult-mu-async
This interactive command takes a completely different approach. Instead of using the built-in mu4e-search functionality, it uses the =mu find= command in the terminal similar to other async consult commands (e.g. consult-ripgrep) and therefore is much faster than mu4e-search and because the search runs asynchronously, it does not freeze the Emacs instance. However, because the mu4e-search is bypassed, some functionalities are limited. For example, once the user selects a hit, only a single email (or a single thread) is shown in the =mu4e-header= buffer and to go back to the full list of search hits, the user has to run the async search again. The approach here is very similar to consult-notmuch but with the advantage that for the search hit (single message or thread), you will still have all the mu4e functionalities in place and therefore you can just use mu4e as you normally would.

The screenshot below shows how =consult-mu-async= can load over 12000 emails very quickly and provide preview buffers as messages are loading. This is similar to =consult-notmuch= functionality but as you can see below =consult-mu= is much faster than =consult-notmuch=. In my tests (only tested with mu4e versions >1.10), consult-mu consistently performs faster than consult-notmuch.

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/Desktop/consult-mu5.gif]]


- consult-mu wrapper
consult-mu package further provides an interactive command called =consult-mu= that calls the variable =consult-mu-default-command=. The idea is that the user can pick either of the two commands above or a user-defined function that build on top of the commands above (e.g. "if condition 1 use dynamic, if condition 2 use async") for common daily use. Personally, I use this to call =consult-mu-dynamic= for most of my everyday use, especially because the =mu4e= built-in search is much snappier with the latest version 1.12 released recently. I then use the async version for cases where I want to search through many emails to find a single email/thread (e.g. a needle in a haystack cases), when I know I won't need the mu4e buffers and other functionalities.

***** contacts
Another lacking feature in mu4e is easy access to list of contacts or searching contacts. By default, mu4e does not keep a list of contacts but rather builds the list dynamically by querying the database. Therefore, as far as I know, to find emails from a specific contact, one needs to run a search query like "From:contact@armindarvish.com". This is extremely counter-intuitive considering that every other email client has a way of searching contacts. If I want to find out the contact information of "John Doe", I should not need to search and see all the email correspondence from/to him. There are perhaps other ways to do this like composing a new blank email and use completion framework (corfu, company ,etc.) in the recipient field but this is even more counter-intuitive. There are other packages like org-contacts, etc. that can be used but then one has to make sure that the database for those packages are up to date and synced on every machine. I think the idea of making a contact list dynamically from messages makes a lot of sense (although it can sometime cause seeing invalid emails), but ideally mu4e would have provided easy commands to see a list of contacts, etc.

consult-mu provides an interactive command, consult-mu-contacts, that provides an intuitive contacts search functionality. It uses "mu cfind" shell command and provides a dynamically updated list of results. The advantage of dynamically updating results is that you do not need to remember how to spell someone's name. If you are not sure whether to use "jon" or "john" you can just type "jo", see the result and decide what to do next as you type. Furthermore, consult-mu-contacts-embark provides functions to call embark actions, for example to see a list of all th messages from the contact or to compose an email to the contact, ...

The screenshot below shows searching contacts, grouping the results based on the "domain" of the email, and then loading all the emails from the recipient using =consult-mu=.

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/Desktop/consult-mu6.gif]]


***** attachments
Attachments are another area where mu4e (and other mail composing modes for that matter) lack some intuitive interactive features. For example, in mu4e-compose mode, by default, =C-c C-a= is bound to =mml-attach-file= which allows you to pick a single file to attach but for each file you have to go through a series of questions to confirm attachment. Other attachment commands like =mail-add-attach= don't ask questions but still only allow picking a single file. In any other modern email client you can pick multiple files to attach. =consult-mu-compose-attach= at least partially addresses this. It allows you to select multiple files by using =embark dwim= or if you prefer by jumping to dired buffer and marking multiple files similar to what Doom emacs does. Similarly, =consult-mu-compose-dettach= allows you to quickly remove attached files in an interactive way.

Here is a screenshot showing some of the functionalities. Depending on the major-mode of the current buffer, consult-mu guesses what you want to do. In a compose buffer, it assumes that the user wants to attach files to the current message and uses minibuffer to query the user to select files. In a dired buffer, it assumes that the user wants to attach marked files (or the file at point) to a message and uses minibuffer for the user to select an open compose buffer or a new one. In any other buffer, it first asks th user to select some files, and then a message buffer. There are customization variables to change the default behavior as you wish. Refer to the [[https://github.com/armindarvish/consult-mu][the GitHub Repo]] and the elisp documentation for further details.

#+attr_org: :width 800px :height nilpx
#+attr_latex: :width 800px :height nilpx
#+attr_html: :width 800px :height nilpx
[[file:~/Desktop/consult-mu-compose.gif]]


**** Thoughts on mu4e and consult-mu vs other tools
:PROPERTIES:
:ID:       909D9897-699A-4328-942F-3ABD7417A328
:END:

***** why use emacs?
One general questions that you may now ask, is "Why in 2024, would/should one even use mu4e?" There are many articles and blog posts on that topic so I won't get into all the details here, but I try to put some of my thoughts on the topic here for context;

Most modern mail clients (thunderbird, outlook, apple mail, ...) are trying to do many things at the same time. Open any of those apps and you will see many panes. One for a list of emails, another for previews, one pane for a calendar, some tabs for todo tasks, etc. and since they are developed by big teams of professional software developers, they are shiny and polished too. But they are not really that good at their main job, going through lots of emails and doing things on each (delete, reply, archive, forward, ...). In fact, if you have a large pile of emails in your inbox, going through them and quickly sorting them, and doing actions on them is really not that efficient in most of those clients. For one, they tend to load 50-100 emails per page, and while one can scroll or click through pages, the interface is really not optimized for organizing thousands of emails efficiently. Of course, there is often the option of setting key shortcuts and whatnot but at the end the interface is designed for general application to serve many customers rather than optimizing your work flow. In this sense, small packages in emacs (or some command line tool for that matter) will always have the advantage over those big shiny desktop apps, because they can be extremely optimized for just one specific task and since most open source software are not about selling the product to the masses, there is rarely any need to bloat everything just to cater to more customers.

another good example of this is the search functionalities in many modern email clients. While most email clients have a way of allowing you to do some advanced search, most people don't ever use those features and stick to just some simple search terms. This is because, the advanced search functionalities are often hidden in some menu/pages, where you have to fill a form to define search queries, or need learning a whole new query syntax to narrow down your search. In emacs, on the other hand, you can use the same syntax and commands that you would use to search for things in any other buffer (code, text, terminal, ...) to search through your email buffer (e.g. =mu4e-header-buffer=), therefore once you learn the basics of navigation and commands in emacs, you can have all sorts of work flows with the same consistent commands.

***** why mu4e instead of other emacs packages (looking at you notmuch)?

Specifically in case of =mu4e=, the simplicity of going through many emails and sorting them with simple strokes of single keys, makes it extremely efficient for dealing with lots of emails. But this is not unique to =mu4e=, other tools like [[https://github.com/notmuch/notmuch][notmuch]] (in combination with [[https://github.com/emacsmirror/consult-notmuch][consult-notmuch]]) can be used for similar work flows. However, when I tried some other tools, I was always missing some features and functionalities that I feel are necessary in 2024. For example, the ability to render HTML messages is necessary because many emails I receive are htmls. With mu4e, I can use the webkit (at least on macOS) to read these emails. Being able to easily and quickly switch between different accounts is another feature that mu4e handles pretty well with =mu4e-contexts=. More importantly, it's relatively easy to integrate what I do in =mu4e= with what I do elsewhere, fr example when I read an email on my mobile phone. With a package like =notmuch= it was much harder to keep everything in sync.

That said, there are areas where notmuch's minimalist approach (especially when combined with the power of consult and embark) is very appealing, and this is why it made sense to create [[https://github.com/armindarvish/consult-mu][consult-mu]]. For example, running =M-x mu4e= opens a main dashboard-like buffer. This is somewhat similar to switching to a different desktop app for reading emails. It may make sense for the time when one sits down to go through her/his mailbox, but what if I am in the middle of writing some code and I just want to jump to a specific email to copy something into my code? Of course, one can run =M-x mu4e-search= instead of going to the dashboard but lack of dynamic completion with search results, means that you have to first run a search query then see the results in a =mu4e-header= buffer with all the hits and then try to find the one email you are looking for. The =consult-notmuch= approach with doing all the search and dynamic completion in minibuffer and showing previews is much superior in this case. =consult-mu= is exactly trying to enable a similar workflow but with mu4e and all its bells and whistles instead of =notmuch= .



* fa
:PROPERTIES:
:EXPORT_LANGUAGE: Farsi
:EXPORT_HUGO_SECTION_FRAG: fa
:END:

** posts
:PROPERTIES:
:EXPORT_HUGO_SECTION_FRAG: post
:END:

*** PUBLISH شروعی ساده
CLOSED: [2023-02-09 Thu 12:01]
:PROPERTIES:
:EXPORT_HUGO_DRAFT: false
:EXPORT_HUGO_SECTION_FRAG: humble_beginnings
:EXPORT_FILE_NAME: index
:TITLE: شروعی ساده
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :subtitle در مورد وبسایت و وبلاگ 
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :summary «معرفی وبسایت»
:END:
#+begin_src yaml :front_matter_extra t
authors:
  - admin
projects: []
featured: false
commentable: true
image:
  caption: 'This is an art made by midjourney AI and Armin'
  focal_point: 'center'
categories: ["نرم افزار", "طراحی وب", "درباره"]
#+end_src

**** *در چند جمله*

من اخیراً تصمیم گرفتم وبسایت قدیمی خود را بازطراحی و احیا کنم و در ادامه تصمیم گرفتم که از این پس نوشته های پراکنده خود را به صورت پست های وبلاگی در همین وبسایت منتشر کنم. به احتمال زیاد موضوعات پستها طیف متنوعی خواهند داشت اما سعی میکنم بیشتر به حوزه تخصص خودم به ویژه تکنولوژی سلامت بپردازم. همچنین دوست دارم تجربیات خودم را در استفاده از ابزارهای نرم افزاری به اشتراک بگذارم، به عنوان مثال پستهایی مثل "چگونه از emacs و ox-hugo برای نوشتن وبلاگ استفاده کنیم" یا "استفاده از NLP و python برای استخراج اطلاعات فنی از گوگل پتنت" و ...

****  *چطور همه چی شروع شد*

من برای اولین بار در سال ۱۳۹۱ شروع به طراحی این وب سایت کردم. در آن زمان، من در دانشگاه درکسل در آمریکا دانشجوی دکترا بودم و در حوزه نانوحفره های مصنوعی به عنوان حسگرهای زیستی مشغول به مطالعه و تحقیق. من می‌خواستم وبسایتی بسازم تا مجموعه تحقیقات و علایقم را به نمایش بگذارم و در این فرآیند درباره طراحی وب، «HTML» و «CSS» نیز اطلاعات بیشتری کسب کنم. وقتی متوجه شدم که می‌توانم وبسایت خود را در فضای صفحه وب شخصی دانشگاه درکسل میزبانی کنم، این پروژه به سادگی شروع شد. پس از تحقیقات اولیه، فکر کردم خوب است که وب سایت را بدون اسکریپت (یعنی فقط با «HTML» و «CSS») طراحی کنم و در عین حال فقط از کار خودم استفاده کنم به این معنی که همه چیز از عناصر طراحی (لوگوها، دکمه ها و غیره) تا بلوک های «HTML» ساخته خودم باشد و نه کار شخص دیگری [fn:کارخودم]! اولین پیش نویس طرح در چند روز آماده شد، اما طراحی و کدنویسی کمی طول کشید، به خصوص به این دلیل که باید CSS را از ابتدا یاد می گرفتم و اجرای طرح اولیه ساده نبود، چرا که از شش ضلعی و حاشیه های مورب استفاده می کرد (برای مثال این [[https://archive.armindarvish.com/research.html][لینک]] ببینید) ، که به راحتی قابل اجرا نبود به خصوص اینکه فقط از «HTML» و «CSS» استفاده می کردم. اولین نسخه در سال ۱۳۹۲ منتشر شد و کمی پس از آن نسخه اولیه فارسی  را به وبسایت اضافه کردم. اما در همین حین، من درگیر تحقیقات دکترای خود شدم و به روز نگه داشتن وبسایت با دو زبان بیشتر از آنچه پیش بینی می کردم وقت میبرد، بنابراین پیشرفت کار کند شد. سپس در اواسط سال ۱۳۹۵ فارغ التحصیل شدم و به کالیفرنیای شمالی نقل مکان کردم تا برای یک شرکت کوچک و نوبنیان کار کنم،  جایی که روزانه به طور متوسط ​​بین ۱۲ تا ۱۴ ساعت وقت می‌گذاشتم [fn:کارزیاد].بنابراین دیگر فرصتی برای کار بر روی پروژه های شخصی از جمله این وب سایت نبود. این نسخه از وبسایت را میتوانید در این [[https://archive.armindarvish.com/index_fa.html][لینک آرشیو]] ببینید.

**** *شروعی تازه*

این پروژه پس از آن برای چند سال بدون به‌روزرسانی رها شد تا اینکه من نهایتاً در سال ۱۳۹۸، تصمیم گرفتم شرکتهای نوپا و ساعات کار طولانی آنها را ترک کنم و به یک شرکت بزرگتر و پایدارتر با ساعات کاری انسانی‌تری بپیوندم. در نتیجه یک بار دیگر این فرصت به وجود آمد که به کار بر روی پروژه های شخصی از جمله این وب سایت بپردازم.  یک بار دیگر فرصتی برای بررسی پروژه‌های شخصی پیدا کردم و تصمیم گرفتم این وبسایت را احیا کنم. ایده احیای وبسایت با این واقعیت که دانشگاه درکسل تصمیم گرفت سروری را که میزبان وبسایت اصلی من بود خاموش کند تقویت شد.در ادامه تصمیم گرفتم که از یک زنجیره ابزار جدید استفاده کنم، زیرا نگهداری وب سایت قدیمی با «HTML» و «CSS» آسان نبود، به علاوه این فرصت خوبی بود برای اینکه دوباره ابزار و مهارت های جدیدی را یاد بگیرم. بعد از کمی تحقیق، تصمیم گرفتم که از[[https://gohugo.io/][«Hugo»]]، به همراه [[https://www.github.com/][«GitHub»]] و [[https://www.netlify.com/][«Netlify»]] استفاده کنم، و بعد از دیدن نمونه های مشابه (مثل این [[https://www.aidanscannell.com/][صفحه]]) و توصیه ها و راهنماهای آنلاین (مثل [[https://www.dsquintana.blog/create-an-academic-website-free-easy-2020/][اینجا]])، تصمیم گرفتم از طرح [[https://academic-demo.netlify.app/][«Academic»]]  از [[https://wowchemy.com/][«wowchemy»]] استفاده کنم و نتیجه همین شد که میبینید.

**** *پس از این*

با استفاده از زنجیره ابزار جدید، به روز رسانی این وب سایت بسیار آسانتر شد. در واقع به روزرسانی آنقدر آسان شد که تصمیم گرفتم می توانم یک وبلاگ هم به این پروژه اضافه کنم. پیش اط این من یادداشت‌های پراکنده‌ای را اینجا و آنجا در پلتفرم‌های رسانه‌های اجتماعی مختلف منتشر کرده بودم، اما اکنون می‌خواهم همه چیز را اینجا در وب‌سایت خودم نگه دارم. هدف جدید من در این پروژه این است که عادت کنم به نوشتن پست های کوتاه در مورد موضوعات جالب و ساخت مجموعه ای از افکار، ایده ها، یادداشتها و دستورالعملهایی که به مرور جمع آوری میکنم. احتمالاً در مورد موضوعات مختلفی که به آنها علاقه دارم مانند بیوتکنولوژی، نانوحسگرها و تکنولوژی سلامت خواهم نوشت. همچنین دوست دارم که تجربه خودم از استفاده از  ابزارهای نرم افزاری مانند استفاده از «emacs» مثلاً برای ایجاد همین پست و یا نحوه استفاده از «midjourney» برای ایجاد پس زمینه های جالب برای وب سایت خود، یا استفاده از «python» و «NLP» برای استخراج اطلاعات فنی از پتنت های گوگل و ... بنویسم.

در حالی که این یک وبلاگ چند زبانه خواهد بود، همه پست ها به همه زبان ها در دسترس نخواهند بود و نوشته های فارسی لزوماً ترجمه نوشته های انگلیسی نیست. افکار، تجربیات و شاید حتی شخصیت من در محیط هایی با زبان های مختلف یکسان نیست و بنابراین، مطالب پست های من نیز انعکاس این تجربیات خواهند بود.



* Footnotes

[fn:mywork] The only exception was the map widget

[fn:کارخودم] البته به جز بعضی المانهای خاص مثل نقشه!

[fn:کارزیاد]توصیه میکنم که این حد از کار را به هیچ عنوان تجربه نکنید چون برای جسم و مغز و روح و روانتون مضره!

[fn:Netlify]Note to self: write another post about choice of tools and how to build a website with hugo, github and netlify!

[fn:longwork] I Don't suggest trying that yourself. It's not good for your physical or mental health!


#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'headline
          (lambda (hl)
            (when (string-equal (org-element-property :raw-value hl) "Humble Beginnings")
              (org-element-map (org-element-contents hl) 'paragraph
              (lambda (paragraph)
                (insert paragraph)
              )))))



#+end_src

* COMMENT Local Variables                                             :ARCHIVE:

# Local Variables:
# eval: (org-hugo-auto-export-mode t)
# eval: (my:blog-minor-mode +1)
# End:
